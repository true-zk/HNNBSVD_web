//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t function_2003(void);
int64_t function_2330(int64_t a1);
void function_2333(int64_t * d);
int64_t function_2340(void);
char * function_2343(char * name);
int64_t function_2350(int32_t a1, int64_t * a2, int64_t * a3);
int32_t function_2353(int32_t how, struct _TYPEDEF_sigset_t * set, struct _TYPEDEF_sigset_t * oset);
int64_t function_2360(int64_t a1);
void function_2363(int64_t * ptr);
int64_t function_2370(int64_t a1);
int32_t * function_2373(void);
int64_t function_2380(int64_t a1, char * a2, int64_t a3);
int32_t function_2383(char * s1, char * s2, int32_t n);
int64_t function_2390(int32_t a1);
int32_t function_2393(int32_t fd);
int64_t function_23a0(int64_t a1, int64_t * a2, int32_t a3);
int32_t function_23a3(int32_t sig, struct sigaction * act, struct sigaction * oact);
int64_t function_23b0(int32_t a1, int64_t a2, int64_t a3);
int32_t function_23b3(int32_t fd, int64_t * buf, int32_t n);
int64_t function_23c0(void);
int32_t function_23c3(void);
int64_t function_23d0(int64_t a1);
int32_t function_23d3(char * s);
int64_t function_23e0(void);
void function_23e3(void);
int64_t function_23f0(int64_t a1);
int32_t function_23f3(int32_t d);
int64_t function_2400(int64_t a1);
int32_t function_2403(struct _IO_FILE * stream);
int64_t function_2410(int64_t * a1, int32_t a2);
int32_t function_2413(struct timeval * tv, struct timezone * tz);
int64_t function_2420(int32_t a1, int64_t * a2, int64_t * a3, int64_t a4);
int32_t function_2423(int32_t fd, int32_t request, ...);
int64_t function_2430(int64_t a1, int64_t a2, int64_t a3);
int32_t function_2433(struct _IO_FILE * stream);
int64_t function_2440(int32_t a1);
int32_t function_2443(int32_t fd);
int64_t function_2450(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
void function_2453(int32_t pri, int32_t flag, char * fmt, int64_t ap);
int64_t function_2460(int32_t a1, int64_t a2, int64_t a3);
int32_t function_2463(int32_t fd, int64_t * buf, int32_t nbytes);
int64_t function_2470(int64_t * a1, int64_t a2, int64_t a3);
char * function_2473(char * s, int32_t n, struct _IO_FILE * stream);
int64_t function_2480(int64_t * a1);
int32_t function_2483(struct _TYPEDEF_sigset_t * set);
int64_t function_2490(int64_t a1, int64_t * a2);
int32_t function_2493(char * file, struct stat * buf);
int64_t function_24a0(int64_t a1, int32_t a2, int64_t a3);
int32_t function_24a3(char * nptr, char ** endptr, int32_t base);
int64_t function_24b0(int64_t a1, int64_t a2, int64_t a3);
int64_t * function_24b3(int64_t * dest, int64_t * src, int32_t n);
int64_t function_24c0(int64_t a1, int64_t a2);
int32_t function_24c3(int32_t pid, int32_t sig);
int64_t function_24d0(void);
int32_t function_24d3(struct _IO_FILE * stream);
int64_t function_24e0(int64_t a1, int64_t * a2, int32_t a3, int32_t a4, int64_t * a5);
int32_t function_24e3(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int64_t function_24f0(int64_t a1, int64_t a2);
int64_t * function_24f3(int32_t size);
int64_t function_2500(int64_t a1);
int32_t function_2503(struct _IO_FILE * stream);
int64_t function_2510(int64_t * a1, char * a2, int64_t a3, int64_t a4, int64_t a5);
int32_t function_2513(char * s, char * format, ...);
int64_t function_2520(int32_t a1);
char * function_2523(int32_t fd);
int64_t function_2530(int64_t a1, char * a2, int64_t a3);
int32_t function_2533(int32_t flag, char * format, ...);
int64_t function_2540(int64_t a1, int32_t a2, int64_t a3, int32_t a4);
int32_t function_2543(struct _IO_FILE * stream, char * buf, int32_t modes, int32_t n);
int64_t function_2550(int64_t a1, int64_t a2, char * a3, char * a4);
void function_2553(int32_t pri, int32_t flag, char * fmt, ...);
int64_t function_2560(int64_t a1);
int64_t function_2563(void);
int64_t function_2570(int64_t a1, int64_t a2);
int32_t function_2573(char * file, int32_t oflag, ...);
int64_t function_2580(char * a1, int64_t * a2);
struct _IO_FILE * function_2583(char * command, char * modes);
int64_t function_2590(int64_t a1);
void function_2593(int32_t status);
int64_t function_25a0(int64_t a1);
int32_t function_25a3(int32_t fd, struct sockaddr * addr, int32_t len);
int64_t function_25b0(char * a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_25b3(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t function_25c0(int64_t a1);
char * function_25c3(char * s);
int64_t function_25d0(int32_t a1);
char * function_25d3(int32_t errnum);
int64_t function_25e0(int64_t a1, int64_t * a2);
int32_t function_25e3(int32_t fd, struct stat * buf);
int64_t function_25f0(int64_t a1);
int32_t function_25f3(struct _IO_FILE * stream);
int64_t function_2600(int64_t * a1, int64_t a2);
int32_t function_2603(struct _TYPEDEF_sigset_t * set, int32_t signo);
int64_t function_2610(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5);
int32_t function_2613(char * s, int32_t flag, int32_t slen, char * format, ...);
int64_t function_2620(int64_t a1, int64_t a2, int32_t a3, int32_t a4);
int32_t function_2623(int32_t domain, int32_t type, int32_t protocol);
int64_t function_2630(void);
int64_t function_2660(void);
int64_t function_26a0(void);
int64_t function_26a3(void);
int64_t function_2730(void);
int64_t function_2733(void);
int64_t function_2743(int64_t a1);
int64_t function_2953(void);
int64_t function_29f3(void);
int64_t function_2a03(int64_t a1, int64_t a2, int64_t a3);
int64_t function_2ab3(int64_t a1, int64_t a2, int64_t a3);
int64_t function_2b53(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_2c93(int64_t a1);
int64_t function_2d33(int64_t result, int64_t a2);
int64_t function_2db3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t function_2e93(int64_t a1, int64_t a2);
int64_t function_2ef3(int64_t a1, int64_t a2);
int64_t function_2f83(int64_t a1);
int64_t function_2fa3(int64_t a1);
int64_t function_30d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3283(void);
int64_t function_33f3(int64_t a1);
int64_t function_34d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_3a33(int64_t a1);
int64_t function_3c23(void);
int64_t function_3cc3(int64_t a1, int64_t a2);
int64_t function_3cf3(int64_t a1);
int64_t function_3d33(int64_t a1, int64_t a2);
int64_t function_4543(void);
int64_t function_4653(int64_t a1);
int64_t function_4bb0(void);
int64_t function_4bb3(void);
int64_t function_4bf7(void);
int64_t Gpm_CharsQueued(void);
int64_t Gpm_Close(void);
int64_t Gpm_cnt_digits(int64_t a1);
int64_t gpm_convert_event(char * a1, int64_t * a2);
int64_t Gpm_FitValuesM(void);
int64_t Gpm_get_console(void);
int64_t Gpm_Getc(void);
int64_t Gpm_GetEvent(int64_t * a1, int64_t a2);
int64_t Gpm_GetLibVersion(void);
int64_t Gpm_GetServerVersion(int32_t a1);
int64_t Gpm_GetSnapshot(void);
int64_t Gpm_HandleRoi(void);
int64_t Gpm_LowerRoi(void);
int64_t Gpm_Open(int64_t * a1, int32_t a2);
int64_t Gpm_PopRoi(void);
int64_t Gpm_PushRoi(void);
int64_t Gpm_RaiseRoi(int64_t a1, int32_t a2);
int64_t Gpm_Repeat(void);
int64_t gpm_report(int64_t a1, char * a2, int64_t a3, char * a4, int64_t a5, int64_t a6);
int64_t Gpm_UseRoi(void);
int64_t Gpm_Wgetch(void);
int64_t Gpm_x_high_y(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int128_t g1; // 0x3e8
int64_t g2 = 0x4a7cf22dfbb8e5; // 0x400
int64_t g3 = 0x2865746972770072; // 0x5066
int64_t g4 = 0x240000019008; // 0x5413
int64_t g5 = -0x33efffffffe4; // 0x541c
int32_t g6 = 0x2d300; // 0x60f
int64_t g7 = -1; // 0x6bc8
int64_t g8 = -1; // 0x6bd8
int64_t g9 = 0; // 0x6be0
int32_t * g10 = NULL; // 0x6f28
int128_t * g11 = NULL; // 0x6f30
int64_t g12 = 0; // 0x6f48
int32_t * g13 = NULL; // 0x6f50
int32_t * g14 = NULL; // 0x6f58
int32_t * g15 = NULL; // 0x6f60
int32_t * g16 = NULL; // 0x6f68
int64_t g17 = 0; // 0x6f78
int64_t g18 = 0; // 0x6f88
int64_t g19 = 0; // 0x6f90
int64_t g20 = 0; // 0x6f98
int32_t g21 = 0; // 0x6fa8
int32_t * g22 = NULL; // 0x6fb0
int32_t * g23 = NULL; // 0x6fb8
int64_t g24 = 0; // 0x6fc0
int32_t * g25 = NULL; // 0x6fc8
int64_t g26 = 0; // 0x6fd0
int64_t g27 = 0; // 0x6fd8
int32_t * g28 = NULL; // 0x6fe8
int64_t g29 = 0; // 0x6ff8
int64_t g30 = 0; // 0x7010
int64_t g31 = 0x186a0; // 0x7018
int64_t g32 = 0; // 0x7020
int64_t g33 = 0x186a0; // 0x7028
char g34 = 0; // 0x7060
int64_t g35 = 0; // 0x7068
int64_t g36 = 0; // 0x7100
char * g37; // 0x7108
int32_t * g38 = NULL; // 0x7180
int32_t g39 = 0; // 0x7190
int32_t g40 = 0; // 0x7191
int32_t g41 = 0; // 0x7192
int64_t g42 = 0; // 0x71a0
int32_t g43 = 0; // 0x71a8
int16_t g44 = 0; // 0x71aa
int32_t g45 = 0; // 0x71bc
int64_t g46 = 0; // 0x71c0
int64_t g47 = 0; // 0x71d0
int16_t g48 = 0; // 0x71d8
int16_t g49 = 0; // 0x71da
int64_t g50 = 0; // 0x71dc
int64_t g51 = 0; // 0x71e0
int64_t g52 = 0; // 0x71e8
int64_t g53 = 0; // 0x71f0
int64_t g54 = 0; // 0x71f8
int64_t g55 = 0; // 0x7200
int64_t g56 = 0; // 0x7208
int32_t g57 = 0; // 0x7210
int128_t g58; // 0x7211
char * g59; // 0x7220
int32_t * g60 = NULL; // 0x72a0
int64_t g61 = 0; // 0x72b0
int32_t g62 = 0; // 0x72b8
int16_t g63 = 0; // 0x72ba
int32_t g64 = 0; // 0x72cc
int32_t g65 = 0; // 0x72cd
int32_t g66 = 0; // 0x72d0
int32_t g67 = 0; // 0x72d1
int32_t g68 = 0; // 0x72d2
int64_t g69 = 0; // 0x72d8
int64_t g70 = 0; // 0x72e0
int64_t g71 = 0; // 0x7380

// ------------------------ Functions -------------------------

// Address range: 0x2003 - 0x2025
int64_t function_2003(void) {
    // 0x2003
    if (*(int64_t *)0x6f80 != 0) {
        // 0x2014
        __gmon_start__();
    }
    // 0x2016
    function_2730();
    return function_4bb0();
}

// Address range: 0x2330 - 0x2331
int64_t function_2330(int64_t a1) {
    // 0x2330
    int64_t result; // 0x2330
    return result;
}

// Address range: 0x2333 - 0x233b
void function_2333(int64_t * d) {
    // 0x2333
    __cxa_finalize(d);
}

// Address range: 0x2340 - 0x2341
int64_t function_2340(void) {
    // 0x2340
    int64_t result; // 0x2340
    return result;
}

// Address range: 0x2343 - 0x234b
char * function_2343(char * name) {
    // 0x2343
    return getenv(name);
}

// Address range: 0x2350 - 0x2351
int64_t function_2350(int32_t a1, int64_t * a2, int64_t * a3) {
    // 0x2350
    int64_t result; // 0x2350
    return result;
}

// Address range: 0x2353 - 0x235b
int32_t function_2353(int32_t how, struct _TYPEDEF_sigset_t * set, struct _TYPEDEF_sigset_t * oset) {
    // 0x2353
    return sigprocmask(how, set, oset);
}

// Address range: 0x2360 - 0x2361
int64_t function_2360(int64_t a1) {
    // 0x2360
    int64_t result; // 0x2360
    return result;
}

// Address range: 0x2363 - 0x236b
void function_2363(int64_t * ptr) {
    // 0x2363
    free(ptr);
}

// Address range: 0x2370 - 0x2371
int64_t function_2370(int64_t a1) {
    // 0x2370
    int64_t result; // 0x2370
    return result;
}

// Address range: 0x2373 - 0x237b
int32_t * function_2373(void) {
    // 0x2373
    return __errno_location();
}

// Address range: 0x2380 - 0x2381
int64_t function_2380(int64_t a1, char * a2, int64_t a3) {
    // 0x2380
    int64_t result; // 0x2380
    return result;
}

// Address range: 0x2383 - 0x238b
int32_t function_2383(char * s1, char * s2, int32_t n) {
    // 0x2383
    return strncmp(s1, s2, n);
}

// Address range: 0x2390 - 0x2391
int64_t function_2390(int32_t a1) {
    // 0x2390
    int64_t result; // 0x2390
    return result;
}

// Address range: 0x2393 - 0x239b
int32_t function_2393(int32_t fd) {
    // 0x2393
    return isatty(fd);
}

// Address range: 0x23a0 - 0x23a1
int64_t function_23a0(int64_t a1, int64_t * a2, int32_t a3) {
    // 0x23a0
    int64_t result; // 0x23a0
    return result;
}

// Address range: 0x23a3 - 0x23ab
int32_t function_23a3(int32_t sig, struct sigaction * act, struct sigaction * oact) {
    // 0x23a3
    return sigaction(sig, act, oact);
}

// Address range: 0x23b0 - 0x23b1
int64_t function_23b0(int32_t a1, int64_t a2, int64_t a3) {
    // 0x23b0
    int64_t result; // 0x23b0
    return result;
}

// Address range: 0x23b3 - 0x23bb
int32_t function_23b3(int32_t fd, int64_t * buf, int32_t n) {
    // 0x23b3
    return write(fd, buf, n);
}

// Address range: 0x23c0 - 0x23c1
int64_t function_23c0(void) {
    // 0x23c0
    int64_t result; // 0x23c0
    return result;
}

// Address range: 0x23c3 - 0x23cb
int32_t function_23c3(void) {
    // 0x23c3
    return getpid();
}

// Address range: 0x23d0 - 0x23d1
int64_t function_23d0(int64_t a1) {
    // 0x23d0
    int64_t result; // 0x23d0
    return result;
}

// Address range: 0x23d3 - 0x23db
int32_t function_23d3(char * s) {
    // 0x23d3
    return strlen(s);
}

// Address range: 0x23e0 - 0x23e1
int64_t function_23e0(void) {
    // 0x23e0
    int64_t result; // 0x23e0
    return result;
}

// Address range: 0x23e3 - 0x23eb
void function_23e3(void) {
    // 0x23e3
    __stack_chk_fail();
}

// Address range: 0x23f0 - 0x23f1
int64_t function_23f0(int64_t a1) {
    // 0x23f0
    int64_t result; // 0x23f0
    return result;
}

// Address range: 0x23f3 - 0x23fb
int32_t function_23f3(int32_t d) {
    // 0x23f3
    return __fdelt_chk(d);
}

// Address range: 0x2400 - 0x2401
int64_t function_2400(int64_t a1) {
    // 0x2400
    int64_t result; // 0x2400
    return result;
}

// Address range: 0x2403 - 0x240b
int32_t function_2403(struct _IO_FILE * stream) {
    // 0x2403
    return pclose(stream);
}

// Address range: 0x2410 - 0x2411
int64_t function_2410(int64_t * a1, int32_t a2) {
    // 0x2410
    int64_t result; // 0x2410
    return result;
}

// Address range: 0x2413 - 0x241b
int32_t function_2413(struct timeval * tv, struct timezone * tz) {
    // 0x2413
    return gettimeofday(tv, tz);
}

// Address range: 0x2420 - 0x2421
int64_t function_2420(int32_t a1, int64_t * a2, int64_t * a3, int64_t a4) {
    // 0x2420
    int64_t result; // 0x2420
    return result;
}

// Address range: 0x2423 - 0x242b
int32_t function_2423(int32_t fd, int32_t request, ...) {
    // 0x2423
    return ioctl(fd, request);
}

// Address range: 0x2430 - 0x2431
int64_t function_2430(int64_t a1, int64_t a2, int64_t a3) {
    // 0x2430
    int64_t result; // 0x2430
    return result;
}

// Address range: 0x2433 - 0x243b
int32_t function_2433(struct _IO_FILE * stream) {
    // 0x2433
    return fgetc(stream);
}

// Address range: 0x2440 - 0x2441
int64_t function_2440(int32_t a1) {
    // 0x2440
    int64_t result; // 0x2440
    return result;
}

// Address range: 0x2443 - 0x244b
int32_t function_2443(int32_t fd) {
    // 0x2443
    return close(fd);
}

// Address range: 0x2450 - 0x2451
int64_t function_2450(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x2450
    int64_t result; // 0x2450
    return result;
}

// Address range: 0x2453 - 0x245b
void function_2453(int32_t pri, int32_t flag, char * fmt, int64_t ap) {
    // 0x2453
    __vsyslog_chk(pri, flag, fmt, ap);
}

// Address range: 0x2460 - 0x2461
int64_t function_2460(int32_t a1, int64_t a2, int64_t a3) {
    // 0x2460
    int64_t result; // 0x2460
    return result;
}

// Address range: 0x2463 - 0x246b
int32_t function_2463(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x2463
    return read(fd, buf, nbytes);
}

// Address range: 0x2470 - 0x2471
int64_t function_2470(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x2470
    int64_t result; // 0x2470
    return result;
}

// Address range: 0x2473 - 0x247b
char * function_2473(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x2473
    return fgets(s, n, stream);
}

// Address range: 0x2480 - 0x2481
int64_t function_2480(int64_t * a1) {
    // 0x2480
    int64_t result; // 0x2480
    return result;
}

// Address range: 0x2483 - 0x248b
int32_t function_2483(struct _TYPEDEF_sigset_t * set) {
    // 0x2483
    return sigemptyset(set);
}

// Address range: 0x2490 - 0x2491
int64_t function_2490(int64_t a1, int64_t * a2) {
    // 0x2490
    int64_t result; // 0x2490
    return result;
}

// Address range: 0x2493 - 0x249b
int32_t function_2493(char * file, struct stat * buf) {
    // 0x2493
    return stat(file, buf);
}

// Address range: 0x24a0 - 0x24a1
int64_t function_24a0(int64_t a1, int32_t a2, int64_t a3) {
    // 0x24a0
    int64_t result; // 0x24a0
    return result;
}

// Address range: 0x24a3 - 0x24ab
int32_t function_24a3(char * nptr, char ** endptr, int32_t base) {
    // 0x24a3
    return strtol(nptr, endptr, base);
}

// Address range: 0x24b0 - 0x24b1
int64_t function_24b0(int64_t a1, int64_t a2, int64_t a3) {
    // 0x24b0
    int64_t result; // 0x24b0
    return result;
}

// Address range: 0x24b3 - 0x24bb
int64_t * function_24b3(int64_t * dest, int64_t * src, int32_t n) {
    // 0x24b3
    return memcpy(dest, src, n);
}

// Address range: 0x24c0 - 0x24c1
int64_t function_24c0(int64_t a1, int64_t a2) {
    // 0x24c0
    int64_t result; // 0x24c0
    return result;
}

// Address range: 0x24c3 - 0x24cb
int32_t function_24c3(int32_t pid, int32_t sig) {
    // 0x24c3
    return kill(pid, sig);
}

// Address range: 0x24d0 - 0x24d1
int64_t function_24d0(void) {
    // 0x24d0
    int64_t result; // 0x24d0
    return result;
}

// Address range: 0x24d3 - 0x24db
int32_t function_24d3(struct _IO_FILE * stream) {
    // 0x24d3
    return fileno(stream);
}

// Address range: 0x24e0 - 0x24e1
int64_t function_24e0(int64_t a1, int64_t * a2, int32_t a3, int32_t a4, int64_t * a5) {
    // 0x24e0
    int64_t result; // 0x24e0
    return result;
}

// Address range: 0x24e3 - 0x24eb
int32_t function_24e3(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x24e3
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x24f0 - 0x24f1
int64_t function_24f0(int64_t a1, int64_t a2) {
    // 0x24f0
    int64_t result; // 0x24f0
    return result;
}

// Address range: 0x24f3 - 0x24fb
int64_t * function_24f3(int32_t size) {
    // 0x24f3
    return malloc(size);
}

// Address range: 0x2500 - 0x2501
int64_t function_2500(int64_t a1) {
    // 0x2500
    int64_t result; // 0x2500
    return result;
}

// Address range: 0x2503 - 0x250b
int32_t function_2503(struct _IO_FILE * stream) {
    // 0x2503
    return fflush(stream);
}

// Address range: 0x2510 - 0x2511
int64_t function_2510(int64_t * a1, char * a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x2510
    int64_t result; // 0x2510
    return result;
}

// Address range: 0x2513 - 0x251b
int32_t function_2513(char * s, char * format, ...) {
    // 0x2513
    return sscanf(s, format);
}

// Address range: 0x2520 - 0x2521
int64_t function_2520(int32_t a1) {
    // 0x2520
    int64_t result; // 0x2520
    return result;
}

// Address range: 0x2523 - 0x252b
char * function_2523(int32_t fd) {
    // 0x2523
    return ttyname(fd);
}

// Address range: 0x2530 - 0x2531
int64_t function_2530(int64_t a1, char * a2, int64_t a3) {
    // 0x2530
    int64_t result; // 0x2530
    return result;
}

// Address range: 0x2533 - 0x253b
int32_t function_2533(int32_t flag, char * format, ...) {
    // 0x2533
    return __printf_chk(flag, format);
}

// Address range: 0x2540 - 0x2541
int64_t function_2540(int64_t a1, int32_t a2, int64_t a3, int32_t a4) {
    // 0x2540
    int64_t result; // 0x2540
    return result;
}

// Address range: 0x2543 - 0x254b
int32_t function_2543(struct _IO_FILE * stream, char * buf, int32_t modes, int32_t n) {
    // 0x2543
    return setvbuf(stream, buf, modes, n);
}

// Address range: 0x2550 - 0x2551
int64_t function_2550(int64_t a1, int64_t a2, char * a3, char * a4) {
    // 0x2550
    int64_t result; // 0x2550
    return result;
}

// Address range: 0x2553 - 0x255b
void function_2553(int32_t pri, int32_t flag, char * fmt, ...) {
    // 0x2553
    __syslog_chk(pri, flag, fmt);
}

// Address range: 0x2560 - 0x2561
int64_t function_2560(int64_t a1) {
    // 0x2560
    int64_t result; // 0x2560
    return result;
}

// Address range: 0x2563 - 0x256b
int64_t function_2563(void) {
    // 0x2563
    return wgetch();
}

// Address range: 0x2570 - 0x2571
int64_t function_2570(int64_t a1, int64_t a2) {
    // 0x2570
    int64_t result; // 0x2570
    return result;
}

// Address range: 0x2573 - 0x257b
int32_t function_2573(char * file, int32_t oflag, ...) {
    // 0x2573
    return open(file, oflag);
}

// Address range: 0x2580 - 0x2581
int64_t function_2580(char * a1, int64_t * a2) {
    // 0x2580
    int64_t result; // 0x2580
    return result;
}

// Address range: 0x2583 - 0x258b
struct _IO_FILE * function_2583(char * command, char * modes) {
    // 0x2583
    return popen(command, modes);
}

// Address range: 0x2590 - 0x2591
int64_t function_2590(int64_t a1) {
    // 0x2590
    int64_t result; // 0x2590
    return result;
}

// Address range: 0x2593 - 0x259b
void function_2593(int32_t status) {
    // 0x2593
    exit(status);
}

// Address range: 0x25a0 - 0x25a1
int64_t function_25a0(int64_t a1) {
    // 0x25a0
    int64_t result; // 0x25a0
    return result;
}

// Address range: 0x25a3 - 0x25ab
int32_t function_25a3(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x25a3
    return connect(fd, addr, len);
}

// Address range: 0x25b0 - 0x25b1
int64_t function_25b0(char * a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x25b0
    int64_t result; // 0x25b0
    return result;
}

// Address range: 0x25b3 - 0x25bb
int32_t function_25b3(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x25b3
    return fwrite(ptr, size, n, s);
}

// Address range: 0x25c0 - 0x25c1
int64_t function_25c0(int64_t a1) {
    // 0x25c0
    int64_t result; // 0x25c0
    return result;
}

// Address range: 0x25c3 - 0x25cb
char * function_25c3(char * s) {
    // 0x25c3
    return strdup(s);
}

// Address range: 0x25d0 - 0x25d1
int64_t function_25d0(int32_t a1) {
    // 0x25d0
    int64_t result; // 0x25d0
    return result;
}

// Address range: 0x25d3 - 0x25db
char * function_25d3(int32_t errnum) {
    // 0x25d3
    return strerror(errnum);
}

// Address range: 0x25e0 - 0x25e1
int64_t function_25e0(int64_t a1, int64_t * a2) {
    // 0x25e0
    int64_t result; // 0x25e0
    return result;
}

// Address range: 0x25e3 - 0x25eb
int32_t function_25e3(int32_t fd, struct stat * buf) {
    // 0x25e3
    return fstat(fd, buf);
}

// Address range: 0x25f0 - 0x25f1
int64_t function_25f0(int64_t a1) {
    // 0x25f0
    int64_t result; // 0x25f0
    return result;
}

// Address range: 0x25f3 - 0x25fb
int32_t function_25f3(struct _IO_FILE * stream) {
    // 0x25f3
    return getc(stream);
}

// Address range: 0x2600 - 0x2601
int64_t function_2600(int64_t * a1, int64_t a2) {
    // 0x2600
    int64_t result; // 0x2600
    return result;
}

// Address range: 0x2603 - 0x260b
int32_t function_2603(struct _TYPEDEF_sigset_t * set, int32_t signo) {
    // 0x2603
    return sigaddset(set, signo);
}

// Address range: 0x2610 - 0x2611
int64_t function_2610(int64_t a1, int64_t a2, int64_t a3, char * a4, int64_t a5) {
    // 0x2610
    int64_t result; // 0x2610
    return result;
}

// Address range: 0x2613 - 0x261b
int32_t function_2613(char * s, int32_t flag, int32_t slen, char * format, ...) {
    // 0x2613
    return __sprintf_chk(s, flag, slen, format);
}

// Address range: 0x2620 - 0x2621
int64_t function_2620(int64_t a1, int64_t a2, int32_t a3, int32_t a4) {
    // 0x2620
    int64_t result; // 0x2620
    return result;
}

// Address range: 0x2623 - 0x262b
int32_t function_2623(int32_t domain, int32_t type, int32_t protocol) {
    // 0x2623
    return socket(domain, type, protocol);
}

// Address range: 0x2630 - 0x2659
int64_t function_2630(void) {
    // 0x2630
    return 0x7050;
}

// Address range: 0x2660 - 0x2699
int64_t function_2660(void) {
    // 0x2660
    return 0;
}

// Address range: 0x26a0 - 0x26a1
int64_t function_26a0(void) {
    // 0x26a0
    int64_t result; // 0x26a0
    return result;
}

// Address range: 0x26a3 - 0x2729
int64_t function_26a3(void) {
    // 0x26a3
    if (g34 != 0) {
        // 0x2728
        int64_t result; // 0x26a3
        return result;
    }
    // 0x26ad
    if (*(int64_t *)0x6ff0 != 0) {
        // 0x26be
        function_2330(*(int64_t *)0x7000);
    }
    // 0x26ca
    if (g35 < ((int64_t)&g9 - (int64_t)&g8 >> 3) - 1) {
        uint64_t v1 = g35 + 1;
        int64_t v2 = v1 > ((int64_t)&g9 - (int64_t)&g8 >> 3) - 1 ? v1 : ((int64_t)&g9 - (int64_t)&g8 >> 3) - 1;
        g35 = v2;
    }
    int64_t result2 = function_2630(); // 0x2713
    g34 = 1;
    return result2;
}

// Address range: 0x2730 - 0x2731
int64_t function_2730(void) {
    // 0x2730
    int64_t result; // 0x2730
    return result;
}

// Address range: 0x2733 - 0x2739
int64_t function_2733(void) {
    // 0x2733
    return function_2660();
}

// Address range: 0x2740 - 0x2741
int64_t Gpm_HandleRoi(void) {
    // 0x2740
    int64_t result; // 0x2740
    return result;
}

// Address range: 0x2743 - 0x2949
int64_t function_2743(int64_t a1) {
    int64_t v1 = a1;
    int32_t * v2 = (int32_t *)(a1 + 12); // 0x2758
    int32_t v3 = *v2; // 0x2758
    int64_t * v4 = (int64_t *)g26; // 0x275b
    int64_t v5 = *v4; // 0x275b
    int64_t v6; // 0x2743
    int16_t * v7; // 0x2743
    int16_t * v8; // 0x2743
    if ((v3 & 5) != 0) {
        int64_t v9 = *(int64_t *)g27; // 0x27ef
        if (v9 != 0) {
            uint16_t v10 = *(int16_t *)(a1 + 8); // 0x27fb
            v6 = v9;
            v7 = (int16_t *)v6;
            uint16_t v11; // 0x2813
            uint64_t v12; // 0x2827
            uint64_t v13; // 0x282b
            if ((int64_t)v10 >= (int64_t)*v7) {
                // 0x2809
                if (*(int16_t *)(v6 + 2) >= v10) {
                    // 0x2813
                    v11 = *(int16_t *)(a1 + 10);
                    v8 = (int16_t *)(v6 + 4);
                    if ((int64_t)*v8 <= (int64_t)v11) {
                        // 0x2821
                        if (*(int16_t *)(v6 + 6) >= v11) {
                            // 0x2827
                            v12 = (int64_t)*(int16_t *)(v6 + 8);
                            v13 = (int64_t)*(char *)(a1 + 1);
                            if ((v13 & v12) >= v12) {
                                // 0x2837
                                if (((int64_t)*(int16_t *)(v6 + 10) & v13) >= v13) {
                                    if (v5 == v6) {
                                        goto lab_0x2771;
                                    } else {
                                        if (v5 == 0) {
                                            goto lab_0x2856;
                                        } else {
                                            // 0x284f
                                            if ((*(char *)(v5 + 13) & 4) != 0) {
                                                // 0x28c6
                                                *(int32_t *)&g50 = (int32_t)&g2;
                                                if (v6 != 0) {
                                                    goto lab_0x2856;
                                                } else {
                                                    // 0x28eb
                                                    *v4 = 0;
                                                    goto lab_0x28f3;
                                                }
                                            } else {
                                                goto lab_0x2856;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            int64_t v14 = *(int64_t *)(v6 + 40); // 0x28a0
            while (v14 != 0) {
                // 0x2800
                v6 = v14;
                v7 = (int16_t *)v6;
                if ((int64_t)v10 >= (int64_t)*v7) {
                    // 0x2809
                    if (*(int16_t *)(v6 + 2) >= v10) {
                        // 0x2813
                        v11 = *(int16_t *)(a1 + 10);
                        v8 = (int16_t *)(v6 + 4);
                        if ((int64_t)*v8 <= (int64_t)v11) {
                            // 0x2821
                            if (*(int16_t *)(v6 + 6) >= v11) {
                                // 0x2827
                                v12 = (int64_t)*(int16_t *)(v6 + 8);
                                v13 = (int64_t)*(char *)(a1 + 1);
                                if ((v13 & v12) >= v12) {
                                    // 0x2837
                                    if (((int64_t)*(int16_t *)(v6 + 10) & v13) >= v13) {
                                        if (v5 == v6) {
                                            goto lab_0x2771;
                                        } else {
                                            if (v5 == 0) {
                                                goto lab_0x2856;
                                            } else {
                                                // 0x284f
                                                if ((*(char *)(v5 + 13) & 4) != 0) {
                                                    // 0x28c6
                                                    *(int32_t *)&g50 = (int32_t)&g2;
                                                    if (v6 != 0) {
                                                        goto lab_0x2856;
                                                    } else {
                                                        // 0x28eb
                                                        *v4 = 0;
                                                        goto lab_0x28f3;
                                                    }
                                                } else {
                                                    goto lab_0x2856;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                // 0x28a0
                v14 = *(int64_t *)(v6 + 40);
            }
        }
        if (v5 == 0) {
            goto lab_0x28f3;
        } else {
            // 0x28b6
            if ((*(char *)(v5 + 13) & 4) != 0) {
                // 0x28c6
                *(int32_t *)&g50 = (int32_t)&g2;
            }
            // 0x28eb
            *v4 = 0;
            goto lab_0x28f3;
        }
    } else {
        if (v5 == 0) {
            goto lab_0x28f3;
        } else {
            goto lab_0x2771;
        }
    }
  lab_0x28f3:
    // 0x28f3
    *(int128_t *)&g47 = (int128_t)__asm_movaps(__asm_movdqu(*(int128_t *)&v1));
    g51 = *(int64_t *)(a1 + 16);
    *(int32_t *)&g52 = *(int32_t *)(a1 + 24);
    return *(int64_t *)g24;
  lab_0x2771:;
    uint16_t v15 = *(int16_t *)(v5 + 12); // 0x2771
    if ((v3 & (int32_t)&g6 & (int32_t)v15) == 0) {
      lab_0x2890:
        // 0x2890
        return 0;
    }
    int16_t * v16 = (int16_t *)(v5 + 4); // 0x2743
    int16_t * v17 = (int16_t *)v5; // 0x2743
    int64_t v18 = v5; // 0x2743
    goto lab_0x2787;
  lab_0x2787:
    // 0x2787
    *(int128_t *)&g47 = (int128_t)__asm_movaps(__asm_movdqu(*(int128_t *)&v1));
    g51 = *(int64_t *)(a1 + 16);
    *(int32_t *)&g52 = *(int32_t *)(a1 + 24);
    g48 -= *v17;
    g49 -= *v16;
    return *(int64_t *)(v18 + 16);
  lab_0x2856:;
    int16_t * v19 = (int16_t *)(v6 + 12); // 0x2856
    int16_t v20 = *v19; // 0x2856
    int16_t v21 = v20; // 0x285d
    if ((v20 & 512) == 0) {
        goto lab_0x287b;
    } else {
        // 0x285f
        *(int32_t *)&g50 = 512;
        v21 = *v19;
        goto lab_0x287b;
    }
  lab_0x287b:
    // 0x287b
    *v4 = v6;
    v16 = v8;
    v17 = v7;
    v18 = v6;
    if (((int32_t)v21 & (int32_t)&g6 & *v2) != 0) {
        goto lab_0x2787;
    } else {
        goto lab_0x2890;
    }
}

// Address range: 0x2953 - 0x29f0
int64_t function_2953(void) {
    int64_t v1 = __readfsqword(40); // 0x2958
    int32_t v2; // bp-24, 0x2953
    int64_t v3; // 0x2953
    int64_t v4 = function_2420(*g22, &g4, (int64_t *)&v2, v3); // 0x2988
    int32_t v5; // 0x2953
    int32_t v6; // 0x2953
    if ((int32_t)v4 == -1) {
        goto lab_0x29c7;
    } else {
        uint32_t v7; // 0x2953
        if ((int16_t)v7 != 0) {
            // 0x29e0
            v5 = v7 % 0x10000;
            v6 = v2 % 0x10000;
            if ((int16_t)v2 == 0) {
                // 0x299c
                v5 = 80;
                v6 = 25;
                goto lab_0x29a6;
            } else {
                goto lab_0x29a6;
            }
        } else {
            // 0x299c
            v5 = 80;
            v6 = 25;
            goto lab_0x29a6;
        }
    }
  lab_0x29c7:;
    int64_t result = v1 - __readfsqword(40); // 0x29cc
    if (result != 0) {
        // 0x29eb
        return function_23e0();
    }
    // 0x29d7
    return result;
  lab_0x29a6:;
    int32_t v8 = *g23; // 0x29b4
    *g15 = v5 - v8;
    *g28 = v6 - v8;
    goto lab_0x29c7;
}

// Address range: 0x29f0 - 0x29f1
int64_t Gpm_CharsQueued(void) {
    // 0x29f0
    int64_t result; // 0x29f0
    return result;
}

// Address range: 0x29f3 - 0x29fb
int64_t function_29f3(void) {
    // 0x29f3
    return (uint32_t)g66;
}

// Address range: 0x2a00 - 0x2a01
int64_t Gpm_Repeat(void) {
    // 0x2a00
    int64_t result; // 0x2a00
    return result;
}

// Address range: 0x2a03 - 0x2ab0
int64_t function_2a03(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = __readfsqword(40); // 0x2a12
    int64_t v2 = 0; // bp-184, 0x2a30
    int32_t v3 = *(int32_t *)g11; // 0x2a49
    uint32_t v4 = v3 > 0 ? v3 : 0; // 0x2a4f
    int64_t v5; // bp-168, 0x2a03
    __asm_rep_stosq_memset((char *)&v5, 0, 16);
    int64_t v6 = function_23f0((int64_t)v4); // 0x2a5a
    uint32_t v7 = v4 % 64;
    int64_t * v8 = (int64_t *)((int64_t)&v2 + 16 + 8 * v6); // 0x2a76
    *v8 = (v7 == 0 ? 1 : 1 << (int64_t)v7) | *v8;
    int64_t v9 = function_24e0((int64_t)(v4 + 1), &v5, 0, 0, &v2); // 0x2a7e
    if (v1 != __readfsqword(40)) {
        // 0x2aa8
        return function_23e0();
    }
    // 0x2a9b
    return (int32_t)v9 == 0;
}

// Address range: 0x2ab0 - 0x2ab1
int64_t Gpm_FitValuesM(void) {
    // 0x2ab0
    int64_t result; // 0x2ab0
    return result;
}

// Address range: 0x2ab3 - 0x2b46
int64_t function_2ab3(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a2;
    int32_t v2 = a3; // 0x2ab7
    int32_t v3 = a1;
    switch (v2) {
        case -1: {
            int32_t v4 = *g23 == 0; // 0x2afa
            int32_t v5 = v4 - v3; // 0x2afa
            int32_t v6 = v5 < 0 == (v5 & v3) < 0 ? v4 : v3; // 0x2afc
            int32_t v7 = *g15; // 0x2b06
            int32_t v8 = v6 - v7; // 0x2b08
            int32_t v9 = v8 < 0 == ((v8 ^ v6) & (v6 ^ v7)) < 0 == (v8 != 0) ? v7 : v6; // 0x2b0a
            *(int32_t *)a1 = v9;
            int32_t v10 = *(int32_t *)&v1; // 0x2b13
            int32_t v11 = *g23 == 0; // 0x2b1a
            int32_t v12 = v11 - v10; // 0x2b1a
            int32_t v13 = v12 < 0 == (v12 & v10) < 0 ? v11 : v10; // 0x2b1c
            int32_t v14 = *g28; // 0x2b26
            int32_t v15 = v13 - v14; // 0x2b28
            int32_t v16 = v15 < 0 == ((v15 ^ v13) & (v13 ^ v14)) < 0 == (v15 != 0) ? v14 : v13; // 0x2b2a
            *(int32_t *)a2 = v16;
            return 0;
        }
        case 4: {
            // 0x2b40
            *(int32_t *)a1 = v3 + 1;
            return 0;
        }
    }
    if (v2 > 4) {
        if (v2 != 8) {
            // 0x2ad0
            return 0;
        }
        // 0x2add
        *(int32_t *)a1 = v3 - 1;
        return 0;
    }
    int32_t v17 = a2;
    if (v2 == 1) {
        // 0x2b38
        *(int32_t *)a2 = v17 + 1;
        return 0;
    }
    if (v2 == 2) {
        // 0x2acd
        *(int32_t *)a2 = v17 - 1;
    }
    // 0x2ad0
    return 0;
}

// Address range: 0x2b50 - 0x2b51
int64_t gpm_convert_event(char * a1, int64_t * a2) {
    // 0x2b50
    int64_t result; // 0x2b50
    return result;
}

// Address range: 0x2b53 - 0x2c85
int64_t function_2b53(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x2b53
    int64_t v1; // 0x2b53
    char v2 = v1;
    if (v2 == 35) {
        uint32_t v3 = g57 % 32; // 0x2c52
        *(int32_t *)(a2 + 12) = v3 == 0 ? 24 : 16 << v3 | 8;
        function_2410(&g55, 0);
        g57 = 0;
    } else {
        // 0x2b6a
        *(int32_t *)(a2 + 12) = 4;
        function_2410(&g53, 0);
        int32_t v4 = 0; // 0x2b8f
        if (g55 != 0) {
            int64_t v5 = g54 - g56; // 0x2b98
            v4 = (int64_t)(0x20c49ba5e353f7cf * (int128_t)v5 / 0x8000000000000000) / 128 + ((g53 - g55) * (int64_t)&g1 | v5 >> 63) > 249 ? 0 : (int32_t)&g58 - (int32_t)((int64_t)((int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g58) >> 32) - ((int32_t)&g58 >> 31)) + 2 * (int64_t)((int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g58) >> 32) - ((int32_t)&g58 >> 31)));
        }
        // 0x2bf8
        g57 = v4;
        switch (v2) {
            case 33: {
                // 0x2c80
                *(char *)a2 = 2;
                // break -> 0x2c0f
                break;
            }
            case 34: {
                // 0x2c78
                *(char *)a2 = 1;
                // break -> 0x2c0f
                break;
            }
            case 32: {
                // 0x2c70
                *(char *)a2 = 4;
                // break -> 0x2c0f
                break;
            }
        }
    }
    int16_t v6 = -32 - *(int16_t *)g23; // 0x2c1b
    *(int16_t *)(a2 + 8) = v6 + (int16_t)*(char *)(a1 + 1);
    *(int16_t *)(a2 + 10) = v6 + (int16_t)*(char *)(a1 + 2);
    return 0;
}

// Address range: 0x2c90 - 0x2c91
int64_t Gpm_PopRoi(void) {
    // 0x2c90
    int64_t result; // 0x2c90
    return result;
}

// Address range: 0x2c93 - 0x2d26
int64_t function_2c93(int64_t a1) {
    int64_t v1 = *(int64_t *)(a1 + 32); // 0x2c9d
    int64_t * v2 = (int64_t *)(a1 + 40);
    if (v1 != 0) {
        // 0x2ca6
        *(int64_t *)(v1 + 40) = *v2;
    }
    int64_t v3 = *v2; // 0x2cae
    if (v3 != 0) {
        // 0x2cb7
        *(int64_t *)(v3 + 32) = v1;
    }
    int64_t * v4 = (int64_t *)g27; // 0x2cc2
    int64_t result = *v4; // 0x2cc2
    if (result == a1) {
        // 0x2d20
        *v4 = result;
    }
    // 0x2cc8
    if (*(int16_t *)(a1 + 14) != 0) {
        int64_t * v5 = (int64_t *)g26;
        if (*v5 != a1) {
            // 0x2cdb
            return result;
        }
        // 0x2d04
        *v5 = 0;
        return *v4;
    }
    // 0x2cf0
    function_2360(a1);
    int64_t * v6 = (int64_t *)g26;
    if (*v6 != a1) {
        // 0x2cdb
        return *v4;
    }
    // 0x2d04
    *v6 = 0;
    return *v4;
}

// Address range: 0x2d30 - 0x2d31
int64_t Gpm_RaiseRoi(int64_t a1, int32_t a2) {
    // 0x2d30
    int64_t result; // 0x2d30
    return result;
}

// Address range: 0x2d33 - 0x2da5
int64_t function_2d33(int64_t result, int64_t a2) {
    int64_t * v1 = (int64_t *)g27; // 0x2d3b
    int64_t result2 = *v1; // 0x2d3b
    if (result2 == 0) {
        // 0x2d98
        *v1 = result;
        // 0x2d9e
        return result;
    }
    int64_t v2 = a2 == 0 ? result2 : a2; // 0x2d46
    if (v2 == result) {
        // 0x2d9e
        return result2;
    }
    int64_t * v3 = (int64_t *)(result + 32); // 0x2d4f
    int64_t v4 = *v3; // 0x2d4f
    int64_t * v5 = (int64_t *)(result + 40);
    if (v4 != 0) {
        // 0x2d58
        *(int64_t *)(v4 + 40) = *v5;
    }
    int64_t v6 = *v5; // 0x2d60
    if (v6 != 0) {
        // 0x2d69
        *(int64_t *)(v6 + 32) = v4;
    }
    if (result2 == result) {
        // 0x2da0
        *v1 = v6;
    }
    int64_t * v7 = (int64_t *)(v2 + 32); // 0x2d72
    *v3 = *v7;
    *v7 = result;
    int64_t v8 = *v3; // 0x2d7e
    *v5 = v2;
    if (v8 != 0) {
        // 0x2d8b
        *(int64_t *)(v8 + 40) = result;
        return *v1;
    }
    // 0x2d98
    *v1 = result;
    // 0x2d9e
    return result;
}

// Address range: 0x2db0 - 0x2db1
int64_t Gpm_PushRoi(void) {
    // 0x2db0
    int64_t result; // 0x2db0
    return result;
}

// Address range: 0x2db3 - 0x2e8a
int64_t function_2db3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    int64_t v1 = function_24f0(48, a2); // 0x2de0
    if (v1 == 0) {
        // 0x2e79
        return 0;
    }
    // 0x2dee
    if (*(int64_t *)g27 == 0) {
        int64_t * v2 = (int64_t *)g17; // 0x2e67
        if (*v2 == 0) {
            // 0x2e6d
            *v2 = 0x2740;
        }
    }
    // 0x2dfe
    *(int16_t *)v1 = (int16_t)a1;
    *(int16_t *)(v1 + 14) = 0;
    *(int16_t *)(v1 + 2) = (int16_t)a3;
    *(int16_t *)(v1 + 4) = (int16_t)a2;
    *(int16_t *)(v1 + 6) = (int16_t)a4;
    *(int32_t *)(v1 + 8) = -0x10000;
    *(int64_t *)(v1 + 40) = 0;
    *(int64_t *)(v1 + 32) = 0;
    *(int16_t *)(v1 + 12) = (int16_t)a5;
    *(int64_t *)(v1 + 16) = a6;
    *(int64_t *)(v1 + 24) = a7 == 0 ? v1 : a7;
    return Gpm_RaiseRoi(v1, 0);
}

// Address range: 0x2e90 - 0x2e91
int64_t Gpm_UseRoi(void) {
    // 0x2e90
    int64_t result; // 0x2e90
    return result;
}

// Address range: 0x2e93 - 0x2ee1
int64_t function_2e93(int64_t a1, int64_t a2) {
    // 0x2e93
    *(int64_t *)(a1 + 40) = 0;
    *(int16_t *)(a1 + 14) = 1;
    *(int64_t *)(a1 + 32) = 0;
    if (*(int64_t *)g27 != 0) {
        // 0x2eba
        return Gpm_RaiseRoi(a1, 0);
    }
    int64_t * v1 = (int64_t *)g17; // 0x2ecf
    if (*v1 == 0) {
        // 0x2ed5
        *v1 = 0x2740;
    }
    // 0x2eba
    return Gpm_RaiseRoi(a1, 0);
}

// Address range: 0x2ef0 - 0x2ef1
int64_t Gpm_LowerRoi(void) {
    // 0x2ef0
    int64_t result; // 0x2ef0
    return result;
}

// Address range: 0x2ef3 - 0x2f78
int64_t function_2ef3(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)g27; // 0x2efb
    int64_t result = *v1; // 0x2efb
    int64_t v2 = a2; // 0x2f01
    if (a2 == 0) {
        int64_t v3 = *(int64_t *)(result + 40); // 0x2f5b
        v2 = result;
        while (v3 != 0) {
            int64_t v4 = v3;
            v3 = *(int64_t *)(v4 + 40);
            v2 = v4;
        }
    }
    // 0x2f03
    if (v2 == a1) {
        // 0x2f48
        return result;
    }
    int64_t * v5 = (int64_t *)(a1 + 32); // 0x2f08
    int64_t v6 = *v5; // 0x2f08
    int64_t * v7 = (int64_t *)(a1 + 40);
    if (v6 != 0) {
        // 0x2f11
        *(int64_t *)(v6 + 40) = *v7;
    }
    int64_t v8 = *v7; // 0x2f19
    if (v8 != 0) {
        // 0x2f22
        *(int64_t *)(v8 + 32) = v6;
    }
    // 0x2f26
    if (result == a1) {
        // 0x2f70
        *v1 = result;
    }
    int64_t * v9 = (int64_t *)(v2 + 40); // 0x2f2b
    *v7 = *v9;
    *v9 = a1;
    int64_t v10 = *v7; // 0x2f37
    *v5 = v2;
    if (v10 != 0) {
        // 0x2f44
        *(int64_t *)(v10 + 32) = a1;
    }
    // 0x2f48
    return result;
}

// Address range: 0x2f80 - 0x2f81
int64_t Gpm_GetLibVersion(void) {
    // 0x2f80
    int64_t result; // 0x2f80
    return result;
}

// Address range: 0x2f83 - 0x2f97
int64_t function_2f83(int64_t a1) {
    if (a1 != 0) {
        // 0x2f89
        *(int32_t *)a1 = 0x4e84;
    }
    // 0x2f8f
    return (int64_t)"2.1.0";
}

// Address range: 0x2fa0 - 0x2fa1
int64_t Gpm_GetServerVersion(int32_t a1) {
    // 0x2fa0
    int64_t result; // 0x2fa0
    return result;
}

// Address range: 0x2fa3 - 0x30d0
int64_t function_2fa3(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x2fb4
    int32_t v2 = 0; // bp-196, 0x2fce
    int64_t result; // 0x2fa3
    if (*(char *)&g46 == 0) {
        int64_t v3 = function_2580("/usr/sbin/gpm -v", &g3); // 0x3026
        result = 0;
        if (v3 == 0) {
            goto lab_0x2fec;
        } else {
            // 0x3037
            int64_t v4; // bp-184, 0x2fa3
            function_2470(&v4, 128, v3);
            result = 0;
            if ((int32_t)function_2400(v3) != 0) {
                goto lab_0x2fec;
            } else {
                // 0x3058
                int64_t v5; // 0x2fa3
                int64_t v6; // 0x2fa3
                function_2510(&v4, "%*s %s", (int64_t)&g46, v6, v5);
                int64_t v7 = function_23d0((int64_t)&g46); // 0x3074
                *(char *)(v7 + (int64_t)&g46 - 1) = 0;
                int32_t v8; // bp-188, 0x2fa3
                int32_t v9; // bp-192, 0x2fa3
                function_2510(&g46, "%d.%d.%d", (int64_t)&v8, (int64_t)&v9, (int64_t)&v2);
                g45 = 100 * v9 + 0x2710 * v8 + v2;
                goto lab_0x2fd8;
            }
        }
    } else {
        goto lab_0x2fd8;
    }
  lab_0x2fd8:
    // 0x2fd8
    result = &g46;
    if (a1 != 0) {
        // 0x2fe4
        *(int32_t *)a1 = g45;
        result = &g46;
    }
    goto lab_0x2fec;
  lab_0x2fec:
    // 0x2fec
    if (v1 != __readfsqword(40)) {
        // 0x30c7
        return function_23e0();
    }
    // 0x3003
    return result;
}

// Address range: 0x30d0 - 0x30d1
int64_t gpm_report(int64_t a1, char * a2, int64_t a3, char * a4, int64_t a5, int64_t a6) {
    // 0x30d0
    int64_t result; // 0x30d0
    return result;
}

// Address range: 0x30d3 - 0x3280
int64_t function_30d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x30d3
    int64_t v1; // 0x30d3
    if ((char)v1 != 0) {
        // 0x30ef
        int128_t v2; // 0x30d3
        __asm_movaps(v2);
        int128_t v3; // 0x30d3
        __asm_movaps(v3);
        int128_t v4; // 0x30d3
        __asm_movaps(v4);
        int128_t v5; // 0x30d3
        __asm_movaps(v5);
        int128_t v6; // 0x30d3
        __asm_movaps(v6);
        int128_t v7; // 0x30d3
        __asm_movaps(v7);
        int128_t v8; // 0x30d3
        __asm_movaps(v8);
        int128_t v9; // 0x30d3
        __asm_movaps(v9);
    }
    int64_t v10 = __readfsqword(40); // 0x3126
    int32_t v11 = a3; // 0x3136
    int64_t v12; // bp-232, 0x30d3
    int64_t v13; // 0x30d3
    int64_t v14; // 0x30d3
    char * v15; // 0x30d3
    if (v11 == 2) {
        goto lab_0x31b1;
    } else {
        // 0x313b
        v12 = 32;
        v14 = 4;
        v13 = (int64_t)"*** warning ";
        if (v11 == 5) {
            goto lab_0x318a;
        } else {
            if (v11 > 5) {
                // 0x31d0
                v15 = NULL;
                if (v11 == 6) {
                    // 0x31d9
                    function_2550(2, 1, "%s", "O0o.oops(): ");
                    function_2450(2, 1, a4, &v12);
                    function_2590(1);
                    v15 = "*** info ";
                }
                goto lab_0x3227;
            } else {
                // 0x316c
                v15 = "*** info ";
                if (v11 == 3) {
                    goto lab_0x3227;
                } else {
                    // 0x3175
                    v14 = 3;
                    v13 = (int64_t)"*** err ";
                    v15 = NULL;
                    if (v11 != 4) {
                        goto lab_0x3227;
                    } else {
                        goto lab_0x318a;
                    }
                }
            }
        }
    }
  lab_0x31b1:;
    int64_t result = v10 - __readfsqword(40); // 0x31b6
    if (result != 0) {
        // 0x3279
        return function_23e0();
    }
    // 0x31c5
    return result;
  lab_0x318a:
    // 0x318a
    function_2550(v14, 1, "%s", (char *)v13);
    function_2450(v14, 1, a4, &v12);
    goto lab_0x31b1;
  lab_0x3227:
    // 0x3227
    function_2550(6, 1, "%s", v15);
    function_2450(6, 1, a4, &v12);
    goto lab_0x31b1;
}

// Address range: 0x3280 - 0x3281
int64_t Gpm_Close(void) {
    // 0x3280
    int64_t result; // 0x3280
    return result;
}

// Address range: 0x3283 - 0x33eb
int64_t function_3283(void) {
    // 0x3283
    *g10 = 0;
    if (*(int32_t *)g11 == -2) {
        // 0x3360
        function_2530(1, "%c[?1000l", 27);
        int64_t * v1 = (int64_t *)*(int64_t *)0x6f40; // 0x337f
        function_2500(*v1);
        function_2530(1, "%c[?1001r", 27);
        function_2500(*v1);
    } else {
        uint32_t result = *g25; // 0x32b2
        if (result == 0) {
            // 0x32b9
            return result;
        }
        int64_t * v2 = (int64_t *)g12; // 0x32cf
        int64_t v3 = *v2; // 0x32cf
        int64_t v4 = *(int64_t *)(v3 + 16); // 0x32d3
        function_2360(v3);
        *v2 = v4;
        if (v4 != 0) {
            uint32_t v5 = *(int32_t *)g11; // 0x32e5
            if (function_23b0(v5, v4, 16) != 16) {
                int32_t v6 = *(int32_t *)function_2370((int64_t)v5); // 0x33bd
                int64_t v7; // 0x3283
                gpm_report(106, "lib/liblow.c", 4, "write(): %s", function_25d0(v6), v7);
            }
        }
        int32_t v8 = *g25 - 1; // 0x32fe
        *g25 = v8;
        if (v8 != 0) {
            // 0x32b9
            return 0xffffffff;
        }
    }
    uint32_t v9 = *(int32_t *)g11; // 0x3308
    if (v9 >= 0) {
        // 0x330e
        function_2440(v9);
    }
    // 0x3313
    *(int32_t *)g11 = -1;
    function_23a0(20, &g70, 0);
    function_23a0(28, &g71, 0);
    function_2440(*g22);
    *g22 = -1;
    return 0;
}

// Address range: 0x33f0 - 0x33f1
int64_t Gpm_GetEvent(int64_t * a1, int64_t a2) {
    // 0x33f0
    int64_t result; // 0x33f0
    return result;
}

// Address range: 0x33f3 - 0x34cc
int64_t function_33f3(int64_t a1) {
    // 0x33f3
    if (*g25 == 0) {
        // 0x3474
        return 0;
    }
    uint32_t v1 = *(int32_t *)g11; // 0x3419
    int64_t v2 = function_2460(v1, a1, 28); // 0x341b
    int64_t result = v2 & 0xffffffff; // 0x3423
    int32_t v3 = v2; // 0x3426
    switch (v3) {
        case 28: {
            int16_t * v4 = (int16_t *)(a1 + 8); // 0x348f
            int16_t v5 = (int16_t)*g23; // 0x348f
            *v4 = *v4 - v5;
            int16_t * v6 = (int16_t *)(a1 + 10); // 0x3493
            *v6 = *v6 - v5;
            return 1;
        }
        case 0: {
            // 0x34a0
            int64_t v7; // 0x33f3
            int64_t v8; // 0x33f3
            gpm_report(478, "lib/liblow.c", 3, "Warning: closing connection", v8, v7);
            Gpm_Close();
            return result;
        }
    }
    if (v3 == -1) {
        // 0x3434
        if (*(int32_t *)function_2370((int64_t)v1) == 11) {
            // 0x3474
            return result;
        }
    }
    // 0x343e
    gpm_report(489, "lib/liblow.c", 3, "Read too few bytes (%i) at %s:%d", result, (int64_t)"lib/liblow.c");
    // 0x3474
    return 0xffffffff;
}

// Address range: 0x34d0 - 0x34d1
int64_t Gpm_Getc(void) {
    // 0x34d0
    int64_t result; // 0x34d0
    return result;
}

// Address range: 0x34d3 - 0x3a29
int64_t function_34d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1; // bp-216, 0x34e5
    int64_t v2 = __readfsqword(40); // 0x34e9
    function_24d0();
    int32_t v3 = g64; // 0x3504
    g64 = &g65;
    int64_t v4; // 0x34d3
    if (v3 == 0) {
        // 0x3884
        function_2540(v1, 0, 2, 0);
        v4 = 2;
        if (*g25 != 0) {
            goto lab_0x352c;
        } else {
            goto lab_0x38a7;
        }
    } else {
        // 0x351b
        v4 = &g65;
        if (*g25 == 0) {
            goto lab_0x38a7;
        } else {
            goto lab_0x352c;
        }
    }
  lab_0x3650_2:;
    // 0x3650
    int64_t v5; // 0x34d3
    int64_t v6 = v5;
    int32_t * v7 = g14; // 0x3650
    *v7 = 1;
    int64_t result = v6 & 0xffffffff; // 0x365d
    goto lab_0x38e4;
  lab_0x352c:;
    // 0x352c
    int64_t v9; // 0x34d3
    int64_t v10 = v9;
    int32_t * v11 = g16; // 0x352c
    uint32_t v12 = *v11; // 0x3533
    int64_t v8; // 0x34d3
    if (v12 != 0) {
        // 0x3910
        v8 = v10;
        if (v2 == __readfsqword(40)) {
            int64_t v13 = g17; // 0x3923
            int64_t result2 = *(int64_t *)v13; // 0x3938
            return result2;
        }
        goto lab_0x3999;
    } else {
        // 0x353d
        int64_t v14; // 0x34fc
        uint64_t v15 = 0x100000000 * v14 / 0x100000000; // 0x3501
        int32_t * v16 = g14; // 0x353d
        int128_t * v17 = g11; // 0x3544
        *v16 = 0;
        uint32_t v18 = *(int32_t *)v17; // 0x3551
        if (v18 < 0) {
            if (v18 != -2) {
                // 0x3951
                v8 = v10;
                if (v2 == __readfsqword(40)) {
                    int64_t v19 = v1; // 0x3964
                    return function_2430(v19, (int64_t)v12, v10);
                }
                goto lab_0x3999;
            } else {
                uint32_t v20 = g66; // 0x366b
                if (v20 != 0) {
                    int64_t v21 = (int64_t)v20 + 0xffffffff; // 0x397e
                    g66 = v21;
                    uint32_t v22 = *(int32_t *)(0x100000000 * v21 / 0x40000000 + (int64_t)&g60); // 0x3990
                    result = v22;
                } else {
                    int64_t v23 = v15 + 1 & 0xffffffff; // 0x3682
                    int64_t v24 = g18; // 0x3689
                    int64_t v25 = 1 << v15 % 64;
                    int64_t * v26 = (int64_t *)v24;
                    __asm_rep_stosq_memset((char *)&g59, 0, 16);
                    int64_t v27 = function_23f0(v15); // 0x36b1
                    int64_t * v28 = (int64_t *)(8 * v27 + (int64_t)&g59); // 0x36bd
                    int64_t v29 = *v28; // 0x36bd
                    *v28 = v29 | v25;
                    *v26 = 2;
                    while ((int32_t)function_24e0(v23, (int64_t *)&g59, 0, 0, v26) == 0) {
                        // 0x36a0
                        __asm_rep_stosq_memset((char *)&g59, 0, 16);
                        v27 = function_23f0(v15);
                        v28 = (int64_t *)(8 * v27 + (int64_t)&g59);
                        v29 = *v28;
                        *v28 = v29 | v25;
                        *v26 = 2;
                    }
                    int64_t v30 = v1; // 0x36d8
                    int64_t v31 = function_2430(v30, (int64_t)&g59, 0); // 0x36dc
                    int32_t v32 = v31;
                    while (v32 == 27) {
                        // 0x36ee
                        __asm_rep_stosq_memset((char *)&g59, 0, 16);
                        int64_t v33 = function_23f0(v15); // 0x36ff
                        int64_t * v34 = (int64_t *)(8 * v33 + (int64_t)&g59); // 0x370f
                        int64_t v35 = *v34; // 0x370f
                        *v34 = v35 | v25;
                        g33 = 0x186a0;
                        int64_t v36 = function_24e0(v23, (int64_t *)&g59, 0, 0, &g32); // 0x3725
                        if ((int32_t)v36 == 0) {
                            // break -> 0x3a1f
                            break;
                        }
                        int64_t v37 = v1; // 0x3732
                        int64_t v38 = function_2430(v37, (int64_t)&g59, 0); // 0x3736
                        int32_t v39 = v38;
                        if (v39 != 91) {
                            int32_t v40 = g66; // 0x39fb
                            g66 = &g67;
                            *(int32_t *)(4 * (int64_t)v40 + (int64_t)&g60) = v39;
                            result = v31 & 0xffffffff;
                            goto lab_0x38e4;
                        }
                        // 0x3746
                        __asm_rep_stosq_memset((char *)&g59, 0, 16);
                        int64_t v41 = function_23f0(v15); // 0x3757
                        int64_t * v42 = (int64_t *)(8 * v41 + (int64_t)&g59); // 0x3767
                        int64_t v43 = *v42; // 0x3767
                        *v42 = v43 | v25;
                        g33 = 0x186a0;
                        int64_t v44 = function_24e0(v23, (int64_t *)&g59, 0, 0, &g32); // 0x377d
                        if ((int32_t)v44 == 0) {
                            int32_t v45 = g66; // 0x39d3
                            g66 = &g67;
                            *(int32_t *)(4 * (int64_t)v45 + (int64_t)&g60) = 91;
                            result = v31 & 0xffffffff;
                            goto lab_0x38e4;
                        }
                        int64_t v46 = v1; // 0x378a
                        int64_t v47 = function_2430(v46, (int64_t)&g59, 0); // 0x378e
                        int64_t v48 = v47 & 0xffffffff; // 0x3793
                        if ((int32_t)v47 != 77) {
                            goto lab_0x39a0;
                        }
                        int64_t v49 = v1; // 0x379e
                        int64_t v50 = function_2430(v49, (int64_t)&g59, v48); // 0x37a5
                        char v51 = v50; // bp-68, 0x37ad
                        function_2430(v49, (int64_t)&g59, v48);
                        function_2430(v49, (int64_t)&g59, v48);
                        gpm_convert_event(&v51, &g61);
                        int64_t v52 = g17; // 0x37e3
                        int64_t v53 = *(int64_t *)v52; // 0x37ea
                        if (v53 != 0) {
                            int32_t v54 = v53;
                            v5 = v53;
                            if (v54 != 0) {
                                goto lab_0x3650_2;
                            }
                        }
                        __asm_rep_stosq_memset((char *)&g59, 0, 16);
                        v27 = function_23f0(v15);
                        v28 = (int64_t *)(8 * v27 + (int64_t)&g59);
                        v29 = *v28;
                        *v28 = v29 | v25;
                        *v26 = 2;
                        while ((int32_t)function_24e0(v23, (int64_t *)&g59, 0, 0, v26) == 0) {
                            // 0x36a0
                            __asm_rep_stosq_memset((char *)&g59, 0, 16);
                            v27 = function_23f0(v15);
                            v28 = (int64_t *)(8 * v27 + (int64_t)&g59);
                            v29 = *v28;
                            *v28 = v29 | v25;
                            *v26 = 2;
                        }
                        // 0x36d8
                        v30 = v1;
                        v31 = function_2430(v30, (int64_t)&g59, 0);
                        v32 = v31;
                    }
                    // 0x3a1f
                    result = v31 & 0xffffffff;
                }
                goto lab_0x38e4;
            }
        } else {
            int64_t v55 = g18; // 0x356a
            int64_t v56 = 1 << v15 % 64;
            int32_t v57 = v15; // 0x3574
            int32_t v58 = v18 - v57; // 0x3574
            int64_t v59 = v58 < 0 == ((v58 ^ v18) & (v18 ^ v57)) < 0 ? (int64_t)v18 : v15;
            int64_t v60 = v59 + 1 & 0xffffffff; // 0x357e
            int64_t v61 = (int64_t)&v1 + 16;
            int64_t * v62 = (int64_t *)v55;
            int64_t v63; // 0x3600
            while (true) {
                int32_t * v64 = g13; // 0x3582
                int32_t v65 = *v64; // 0x3589
                if (v65 != 0) {
                    int32_t * v66 = g23; // 0x3820
                    int16_t v67 = *(int16_t *)&g62; // 0x3827
                    int64_t v68 = g19; // 0x382e
                    int32_t v69 = *v66; // 0x3835
                    int64_t v70 = g20; // 0x3837
                    int64_t v71 = v68 + 1; // 0x383e
                    *(char *)v71 = 2;
                    int64_t v72 = *(int64_t *)v70; // 0x3842
                    int16_t v73 = v69;
                    int16_t v74 = v67 + v73; // 0x3847
                    *(int16_t *)v72 = v74;
                    *(int16_t *)(v72 + 4) = v74;
                    int16_t v75 = g63; // 0x384e
                    int16_t v76 = v75 + v73; // 0x384e
                    *(int16_t *)(v72 + 2) = v76;
                    *(int16_t *)(v72 + 6) = v76;
                    *(int16_t *)(v72 + 8) = 3;
                    int32_t * v77 = g22; // 0x386b
                    int32_t v78 = *v77; // 0x3876
                    function_2420(v78, &g5, (int64_t *)v71, v68);
                }
                while (true) {
                  lab_0x3598:;
                    // 0x3598
                    int64_t v79; // bp-200, 0x34d3
                    __asm_rep_stosq_memset((char *)&v79, 0, 16);
                    int64_t v80 = function_23f0(v15); // 0x35a8
                    uint32_t v81 = *(int32_t *)v17; // 0x35ad
                    int64_t * v82 = (int64_t *)(8 * v80 + v61); // 0x35b1
                    int64_t v83 = *v82; // 0x35b1
                    *v82 = v83 | v56;
                    if (v81 >= 0) {
                        int64_t v84 = function_23f0((int64_t)v81); // 0x35ba
                        uint32_t v85 = *(int32_t *)v17; // 0x35bf
                        uint32_t v86 = v85 % 64;
                        int64_t v87 = v86 == 0 ? 1 : 1 << (int64_t)v86;
                        int64_t * v88 = (int64_t *)(8 * v84 + v61); // 0x35ce
                        int64_t v89 = *v88; // 0x35ce
                        *v88 = v87 | v89;
                    }
                    // 0x35d3
                    *v62 = 2;
                    int64_t v90 = function_24e0(v60, &v79, 0, 0, v62); // 0x35e7
                    switch ((int32_t)v90) {
                        case 0: {
                            goto lab_0x3598;
                        }
                        case -1: {
                            goto lab_0x3582;
                        }
                        default: {
                            goto lab_0x35f5;
                        }
                    }
                }
              lab_0x35f5:;
                int64_t v91 = function_23f0(v15); // 0x35f8
                int64_t v92 = *(int64_t *)(8 * v91 + v61); // 0x3600
                v63 = v92 & v56;
                if (v63 != 0) {
                    // break -> 0x38d8
                    break;
                }
                int64_t v93 = Gpm_GetEvent(&g61, v63); // 0x3612
                if ((int32_t)v93 != 0) {
                    int64_t v94 = g17; // 0x361f
                    int64_t v95 = *(int64_t *)v94; // 0x3626
                    v5 = v95;
                    if (v95 != 0 && (int32_t)v95 != 0) {
                        goto lab_0x3650_2;
                    }
                }
              lab_0x3582:;
            }
            int64_t v96 = v1; // 0x38d8
            result = function_2430(v96, v63, 0) & 0xffffffff;
            goto lab_0x38e4;
        }
    }
  lab_0x38a7:
    // 0x38a7
    v8 = v4;
    if (v2 == __readfsqword(40)) {
        // 0x38be
        return function_25f0(v1);
    }
    goto lab_0x3999;
  lab_0x3999:
    // 0x3999
    function_23e0();
  lab_0x39a0:
    // 0x39a0
    *(int32_t *)(4 * (int64_t)g66 + (int64_t)&g60) = (int32_t)v8;
    g66 = &g68;
    *(int32_t *)((int64_t)&g60 + 4 * (int64_t)(int32_t)&g67) = 91;
    int32_t v97; // 0x34d3
    result = v97;
    goto lab_0x38e4;
  lab_0x38e4:
    // 0x38e4
    v8 = &g68;
    if (v2 == __readfsqword(40)) {
        // 0x38fb
        return result;
    }
    goto lab_0x3999;
}

// Address range: 0x3a30 - 0x3a31
int64_t Gpm_GetSnapshot(void) {
    // 0x3a30
    int64_t result; // 0x3a30
    return result;
}

// Address range: 0x3a33 - 0x3c20
int64_t function_3a33(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x3a42
    int64_t v2 = 0; // bp-232, 0x3a5b
    int64_t v3; // 0x3a33
    int64_t v4; // 0x3a33
    if (g45 == 0) {
        // 0x3b48
        if (Gpm_GetServerVersion(0) == 0) {
            // 0x3b97
            int64_t v5; // 0x3a33
            gpm_report(97, "lib/libxtra.c", 5, "can't get gpm server version", v5, v4);
        }
        int64_t v6 = g45; // 0x3b5b
        gpm_report(99, "lib/libxtra.c", 3, "libgpm: got server version as %i", v6, v4);
        v3 = v6;
    }
    // 0x3a74
    int64_t result; // 0x3a33
    if (g45 < 0x264a) {
        // 0x3bc0
        gpm_report(102, "lib/libxtra.c", 3, "gpm server version too old to obtain status info", v3, v4);
        result = 0xffffffff;
    } else {
        int32_t v7 = *(int32_t *)g11; // 0x3a86
        if (v7 < 1) {
            // 0x3be9
            gpm_report(107, "lib/libxtra.c", 3, "gpm connection must be open to obtain status info", v3, v4);
            result = 0xffffffff;
        } else {
            // 0x3a91
            int64_t v8; // bp-168, 0x3a33
            __asm_rep_stosq_memset((char *)&v8, 0, 16);
            int64_t v9 = function_23f0((int64_t)v7); // 0x3abd
            uint32_t v10 = *(int32_t *)g11; // 0x3ac2
            uint32_t v11 = v10 % 64;
            int64_t * v12 = (int64_t *)((int64_t)&v2 + 64 + 8 * v9); // 0x3ad8
            *v12 = (v11 == 0 ? 1 : 1 << (int64_t)v11) | *v12;
            int64_t v13 = function_24e0((int64_t)(v10 + 1), &v8, 0, 0, &v2); // 0x3ae2
            result = 0;
            if ((int32_t)v13 != 1) {
                // 0x3af2
                int64_t v14; // bp-200, 0x3a33
                int64_t v15 = a1 == 0 ? (int64_t)&v14 : a1;
                int64_t v16; // bp-216, 0x3a33
                int64_t v17 = &v16; // 0x3af5
                function_23b0(*(int32_t *)g11, v17, 16);
                result = 0xffffffff;
                if ((int32_t)Gpm_GetEvent((int64_t *)v15, v17) == 1) {
                    int32_t * v18 = (int32_t *)(v15 + 12); // 0x3b15
                    *v18 = 0;
                    result = (int64_t)*v18;
                }
            }
        }
    }
    // 0x3b1f
    if (v1 != __readfsqword(40)) {
        // 0x3c12
        return function_23e0();
    }
    // 0x3b36
    return result;
}

// Address range: 0x3c20 - 0x3c21
int64_t Gpm_get_console(void) {
    // 0x3c20
    int64_t result; // 0x3c20
    return result;
}

// Address range: 0x3c23 - 0x3cc0
int64_t function_3c23(void) {
    int64_t v1 = __readfsqword(40); // 0x3c37
    int64_t v2; // bp-184, 0x3c23
    int64_t v3 = function_2490((int64_t)"/dev/vc/0", &v2); // 0x3c50
    int64_t v4 = (int64_t)"/dev/vc/0"; // 0x3c57
    int64_t result; // 0x3c23
    if ((int32_t)v3 == 0) {
        goto lab_0x3c75;
    } else {
        int64_t v5 = function_2490((int64_t)"/dev/tty0", &v2); // 0x3c66
        v4 = (int64_t)"/dev/tty0";
        result = 0;
        if ((int32_t)v5 != 0) {
            goto lab_0x3c92;
        } else {
            goto lab_0x3c75;
        }
    }
  lab_0x3c75:;
    int64_t v6 = function_24f0(10, (int64_t)&v2); // 0x3c7a
    result = 0;
    if (v6 != 0) {
        // 0x3c84
        *(int64_t *)v6 = *(int64_t *)v4;
        *(int16_t *)(v6 + 8) = *(int16_t *)(v4 + 8);
        result = v6;
    }
    goto lab_0x3c92;
  lab_0x3c92:
    // 0x3c92
    if (v1 != __readfsqword(40)) {
        // 0x3caf
        return function_23e0();
    }
    // 0x3ca5
    return result;
}

// Address range: 0x3cc0 - 0x3cc1
int64_t Gpm_x_high_y(int64_t a1, int64_t a2) {
    // 0x3cc0
    int64_t result; // 0x3cc0
    return result;
}

// Address range: 0x3cc3 - 0x3ce9
int64_t function_3cc3(int64_t a1, int64_t a2) {
    int32_t v1 = a2; // 0x3cc9
    if (v1 == 0) {
        // 0x3ce8
        return 1;
    }
    // 0x3ccd
    if (v1 < 0) {
        // 0x3ce8
        return 0;
    }
    int64_t result = 1; // 0x3ce0
    result = 0x100000000 * result / 0x100000000 * 0x100000000 * a1 / 0x100000000 & 0xffffffff;
    uint32_t v2 = (int32_t)a2 - 1; // 0x3ce3
    int64_t v3 = v2; // 0x3ce6
    while (v2 != 0) {
        // 0x3ce0
        result = 0x100000000 * result / 0x100000000 * 0x100000000 * a1 / 0x100000000 & 0xffffffff;
        v2 = (int32_t)v3 - 1;
        v3 = v2;
    }
    // 0x3ce8
    return result;
}

// Address range: 0x3cf0 - 0x3cf1
int64_t Gpm_cnt_digits(int64_t a1) {
    // 0x3cf0
    int64_t result; // 0x3cf0
    return result;
}

// Address range: 0x3cf3 - 0x3d30
int64_t function_3cf3(int64_t a1) {
    int32_t v1 = a1; // 0x3cfe
    if (v1 < 0) {
        // 0x3d25
        return 0;
    }
    // 0x3d02
    if (v1 == 0) {
        // 0x3d25
        return 1;
    }
    int64_t result = 0; // 0x3d0f
    result = result + 1 & 0xffffffff;
    int64_t v2 = Gpm_x_high_y(10, result); // 0x3d1c
    while ((a1 & 0xffffffff) >= v2) {
        // 0x3d10
        result = result + 1 & 0xffffffff;
        v2 = Gpm_x_high_y(10, result);
    }
    // 0x3d25
    return result;
}

// Address range: 0x3d30 - 0x3d31
int64_t Gpm_Open(int64_t * a1, int32_t a2) {
    // 0x3d30
    int64_t result; // 0x3d30
    return result;
}

// Address range: 0x3d33 - 0x4532
int64_t function_3d33(int64_t a1, int64_t a2) {
    int64_t v1 = a2 & 0xffffffff; // 0x3d38
    int64_t v2 = __readfsqword(40); // 0x3d52
    int64_t v3 = function_2340(); // 0x3d65
    int64_t v4; // 0x3d33
    int32_t result; // 0x3d33
    int64_t v5; // 0x3d33
    int64_t v6; // 0x3d33
    if (v3 == 0) {
        goto lab_0x3db0;
    } else {
        // 0x3d6f
        if ((int32_t)function_2380(v3, "xterm", 5) != 0) {
            goto lab_0x3db0;
        } else {
            // 0x3d87
            if (*g10 == 0) {
                // 0x4110
                *(int32_t *)g11 = -2;
                function_2530(1, "%c[?1001s", 27);
                int64_t v7 = *(int64_t *)0x6f40; // 0x4135
                int64_t * v8 = (int64_t *)v7; // 0x413c
                function_2500(*v8);
                function_2530(1, "%c[?1000h", 27);
                function_2500(*v8);
                *g25 = 1;
                result = *(int32_t *)g11;
                v6 = (int64_t)g11;
                v5 = v7;
                v4 = v1;
            } else {
                // 0x3d98
                result = *(int32_t *)g11;
                v5 = a1;
                v4 = v1;
            }
            goto lab_0x3f37;
        }
    }
  lab_0x3db0:;
    // 0x3db0
    int64_t v9; // 0x3d33
    int64_t v10; // 0x3d33
    int64_t v11; // 0x3d33
    int64_t v12; // 0x3d33
    int64_t v13; // 0x3d33
    int64_t v14; // 0x3d33
    if (g69 == 0) {
        int64_t v15 = Gpm_get_console(); // 0x4180
        g69 = v15;
        if (v15 != 0) {
            goto lab_0x3dbe;
        } else {
            // 0x4195
            gpm_report(239, "lib/liblow.c", 4, "unable to open gpm console, check your /dev filesystem!\n", v14, v13);
            v12 = (int64_t)g25;
            v9 = (int64_t)g11;
            v10 = g12;
            v11 = v1;
            goto lab_0x42c0;
        }
    } else {
        goto lab_0x3dbe;
    }
  lab_0x3dbe:;
    int64_t v16 = (int64_t)g25; // 0x3dbe
    uint32_t v17 = *g25; // 0x3dcc
    int64_t v18; // 0x3d33
    int64_t v19; // 0x3d33
    int64_t v20; // 0x3d33
    int64_t v21; // 0x3d33
    if (v17 != 0) {
        goto lab_0x3ddc;
    } else {
        uint32_t v22 = *g10; // 0x3dd2
        v21 = v22;
        v20 = v16;
        v19 = a1;
        v18 = v1;
        if (v22 != 0) {
            goto lab_0x4310;
        } else {
            goto lab_0x3ddc;
        }
    }
  lab_0x3ddc:
    // 0x3ddc
    *g10 = 1;
    int64_t v23 = function_24f0(24, (int64_t)v17); // 0x3de7
    v20 = v16;
    v19 = a1;
    int64_t v24 = 0; // 0x3df2
    v18 = v1;
    int64_t v25; // 0x3d33
    int64_t v26; // 0x3d33
    int64_t v27; // 0x3d33
    int64_t v28; // 0x3d33
    int64_t v29; // 0x3d33
    int64_t v30; // 0x3d33
    int64_t v31; // 0x3d33
    int64_t v32; // 0x3d33
    int64_t v33; // 0x3d33
    int64_t v34; // 0x3d33
    int64_t v35; // 0x3d33
    int64_t v36; // 0x3d33
    int64_t v37; // 0x3d33
    int64_t v38; // 0x3d33
    int64_t v39; // 0x3d33
    int64_t v40; // 0x3d33
    int64_t v41; // 0x3d33
    int64_t v42; // 0x3d33
    int64_t v43; // 0x3d33
    int64_t v44; // 0x3d33
    int64_t v45; // 0x3df8
    int32_t * v46; // 0x4090
    if (v23 == 0) {
        goto lab_0x4310;
    } else {
        int64_t * v47 = (int64_t *)g12; // 0x3dff
        *v47 = v23;
        int64_t * v48 = (int64_t *)(v23 + 16); // 0x3e07
        *v48 = *v47;
        *(int32_t *)(a1 + 8) = (int32_t)function_23c0();
        int64_t v49 = *v48; // 0x3e14
        if (v49 == 0) {
            // 0x4090
            v46 = (int32_t *)(a1 + 12);
            *v46 = 0;
            int32_t v50 = a2; // 0x4097
            if (v50 >= 0 == (v50 != 0)) {
                // 0x41d0
                *v46 = v50;
                int64_t v51 = g69; // 0x41d4
                int64_t v52 = function_23d0(v51); // 0x41db
                int64_t v53; // 0x3dcc
                int64_t v54 = function_24f0(0x100000000 * Gpm_cnt_digits(v1) / 0x100000000 + v52, v53); // 0x41f1
                v41 = v16;
                v38 = a1;
                v26 = v23;
                v29 = v45;
                v31 = v1;
                v34 = v54;
                v42 = v16;
                v39 = a1;
                v27 = v23;
                v30 = v45;
                v32 = v1;
                v33 = 0;
                if (v54 == 0) {
                    goto lab_0x450e;
                } else {
                    goto lab_0x4202;
                }
            } else {
                if (v50 != 0) {
                    int64_t v55 = g69; // 0x4380
                    v35 = function_25c0(v55);
                    goto lab_0x4253;
                } else {
                    // 0x40a6
                    if ((int32_t)function_2390(0) != 0) {
                        int64_t v56 = function_2520(0); // 0x439a
                        v36 = v56;
                        if (v56 == 0) {
                            goto lab_0x40b5;
                        } else {
                            goto lab_0x43ab;
                        }
                    } else {
                        goto lab_0x40b5;
                    }
                }
            }
        } else {
            // 0x3e22
            *(int32_t *)(a1 + 12) = *(int32_t *)(v49 + 12);
            v43 = v21;
            v40 = v16;
            v37 = a1;
            v44 = (int64_t)*g22;
            v25 = v23;
            v28 = g12;
            goto lab_0x3e31;
        }
    }
  lab_0x3f37:
    // 0x3f37
    if (v2 == __readfsqword(40)) {
        // 0x3f4e
        return result;
    }
    // 0x4509
    function_23e0();
    v42 = v6;
    v39 = v5;
    int64_t v57; // 0x3d33
    int64_t v58 = v57; // 0x4509
    int64_t v59; // 0x3d33
    int64_t v60 = v59; // 0x4509
    int64_t v61; // 0x3d33
    v27 = v61;
    int64_t v62; // 0x3d33
    v30 = v62;
    v32 = v4;
    int64_t v63; // 0x3d33
    v33 = v63;
    goto lab_0x450e;
  lab_0x42c0:;
    // 0x42c0
    int64_t v78; // 0x3d33
    int64_t v79; // 0x3d33
    gpm_report(402, "lib/liblow.c", 4, "Oh, oh, it's an error! possibly I die! ", v78, v79);
    int64_t v116 = v12; // 0x42d6
    int64_t v117 = v78; // 0x42d6
    int64_t v118 = v79; // 0x42d6
    int64_t v119 = v9; // 0x42d6
    int64_t v120 = v10; // 0x42d6
    int64_t v121 = v11; // 0x42d6
    goto lab_0x42db;
  lab_0x4310:
    // 0x4310
    result = -1;
    v6 = v20;
    v5 = v19;
    int64_t v137; // 0x3d33
    v57 = v137;
    int64_t v138; // 0x3d33
    v59 = v138;
    v61 = v24;
    int64_t v139; // 0x3d33
    v62 = v139;
    v4 = v18;
    int64_t v140; // 0x3d33
    v63 = v140;
    goto lab_0x3f37;
  lab_0x450e:
    // 0x450e
    gpm_report(270, "lib/liblow.c", 6, "I couln't get any memory! I die! :(", v58, v60);
    v41 = v42;
    v38 = v39;
    int64_t v64 = v60; // 0x452d
    v26 = v27;
    v29 = v30;
    v31 = v32;
    v34 = v33;
    goto lab_0x4202;
  lab_0x42db:;
    int64_t * v131 = (int64_t *)v120; // 0x42db
    int64_t v132 = *v131; // 0x42db
    int64_t v133 = v132; // 0x42e2
    int64_t v134 = 0; // 0x42e2
    if (v132 != 0) {
        int64_t v135 = *(int64_t *)(v133 + 16); // 0x42eb
        function_2360(v133);
        *v131 = v135;
        v133 = v135;
        v134 = v135;
        while (v135 != 0) {
            // 0x42e8
            v135 = *(int64_t *)(v133 + 16);
            function_2360(v133);
            *v131 = v135;
            v133 = v135;
            v134 = v135;
        }
    }
    uint32_t v136 = *(int32_t *)v119; // 0x42fd
    if (v136 >= 0) {
        // 0x4305
        function_2440(v136);
    }
    // 0x430a
    *(int32_t *)v116 = 0;
    v20 = v116;
    v19 = v134;
    v137 = v117;
    v138 = v118;
    v24 = v119;
    v139 = v120;
    v18 = v121;
    v140 = (int64_t)"lib/liblow.c";
    goto lab_0x4310;
  lab_0x4202:;
    int64_t v65 = g69; // 0x4202
    function_24b0(v34, v65, function_23d0(v65) - 1);
    int64_t v66 = v31 & 0xffffffff; // 0x4231
    function_2610(v34 - 1 + function_23d0(v65), 1, -1, "%i", v66);
    goto lab_0x4253;
  lab_0x3e31:;
    // 0x3e31
    int64_t v75; // 0x3d33
    int64_t v105 = v75;
    int64_t v99 = v28;
    int64_t v74; // 0x3d33
    int64_t v98 = v74;
    int64_t v73; // 0x3d33
    int64_t v125 = v73;
    int64_t v146 = v37;
    int64_t v84 = v40;
    __asm_movups(*(int128_t *)v25, __asm_movdqu(*(int128_t *)v146));
    int32_t v80; // bp-336, 0x3d33
    function_2420((int32_t)v44, &g4, (int64_t *)&v80, v43);
    int32_t v81; // 0x3d33
    int32_t v82; // 0x3d33
    uint32_t v153; // 0x3d33
    if ((int16_t)v153 == 0) {
        goto lab_0x3e60;
    } else {
        // 0x3e56
        v81 = v153 % 0x10000;
        v82 = v80 % 0x10000;
        if ((int16_t)v80 != 0) {
            goto lab_0x3e92;
        } else {
            goto lab_0x3e60;
        }
    }
  lab_0x4253:;
    int64_t v67 = v34;
    int64_t v68 = v29;
    int64_t v69 = v41;
    if (*g22 != -1) {
        goto lab_0x3e31;
    } else {
        int64_t v70 = function_2570(v67, 1); // 0x4270
        int32_t v71 = v70; // 0x4275
        *g22 = v71;
        int64_t v72 = v70 & 0xffffffff; // 0x4278
        v43 = (int64_t)"%i";
        v40 = v69;
        v37 = v38;
        v44 = v72;
        v73 = v66;
        v74 = v64;
        v25 = v26;
        v28 = v68;
        v75 = v67;
        if (v71 >= 0) {
            goto lab_0x3e31;
        } else {
            int32_t v76 = *(int32_t *)function_2370(v72); // 0x4287
            int64_t v77 = function_25d0(v76); // 0x4289
            gpm_report(288, "lib/liblow.c", 4, "%s: %s", v67, v77);
            v12 = v69;
            v78 = v67;
            v79 = v77;
            v9 = (int64_t)g11;
            v10 = v68;
            v11 = (int64_t)g22;
            goto lab_0x42c0;
        }
    }
  lab_0x3e60:
    // 0x3e60
    function_25b0("libgpm: zero screen dimension, assuming 80x25.\n", 1, 47, *(int64_t *)g29);
    v80 = 0x500019;
    v81 = 80;
    v82 = 25;
    goto lab_0x3e92;
  lab_0x40b5:
    // 0x40b5
    if ((int32_t)function_2390(1) != 0) {
        int64_t v152 = function_2520(1); // 0x4425
        v36 = v152;
        if (v152 != 0) {
            goto lab_0x43ab;
        } else {
            goto lab_0x40c7;
        }
    } else {
        goto lab_0x40c7;
    }
  lab_0x3e92:;
    int32_t * v83 = (int32_t *)v84; // 0x3ea0
    uint32_t v85 = *v83; // 0x3ea0
    int32_t v86 = *g23; // 0x3ea3
    *g15 = v81 - v86;
    *g28 = v82 - v86;
    *v83 = v85 + 1;
    int64_t v87; // 0x3d33
    int64_t v88; // 0x3d33
    int64_t v89; // 0x3d33
    int64_t v90; // 0x3d33
    int64_t v91; // 0x3d33
    int64_t v92; // bp-216, 0x3d33
    if (v85 == 0) {
        int64_t v93 = function_2620(1, 1, 0, v86); // 0x3f6c
        int64_t v94 = (int64_t)g11; // 0x3f71
        int32_t v95 = v93; // 0x3f7b
        *(int32_t *)g11 = v95;
        if (v95 < 0) {
            int32_t v96 = *(int32_t *)function_2370(1); // 0x447a
            int64_t v97 = function_25d0(v96); // 0x447c
            gpm_report(310, "lib/liblow.c", 4, "socket(): %s", v97, v98);
            v12 = v84;
            v78 = v97;
            v79 = v98;
            v9 = v94;
            v10 = v99;
            v11 = 0;
            goto lab_0x42c0;
        } else {
            int64_t v100 = v93 & 0xffffffff; // 0x3f78
            int64_t v101; // bp-320, 0x3d33
            __asm_rep_stosq_memset((char *)&v101, 0, 12);
            bool v102; // 0x3d33
            int64_t v103 = (v102 ? -96 : 96) + (int64_t)&v101; // 0x3fa0
            *(int16_t *)(v103 | 4) = 0;
            *(int32_t *)v103 = 0;
            int64_t v104 = function_25a0(v100); // 0x3fd3
            v90 = v100;
            v91 = v98;
            v87 = v94;
            v88 = 0;
            v89 = v105;
            if ((int32_t)v104 >= 0) {
                goto lab_0x3ecc;
            } else {
                int32_t * v106 = (int32_t *)function_2370(v100); // 0x3fe5
                int32_t v107 = *v106; // 0x3fe5
                int64_t v108; // 0x3d33
                int64_t v109; // 0x3d33
                if (v107 == 2) {
                    // 0x43d0
                    gpm_report(338, "lib/liblow.c", 2, "cannot find %s; ignoring (gpm disabled?)", (int64_t)"/dev/gpmctl", v98);
                    v109 = v98;
                    v108 = 1;
                } else {
                    int64_t v110 = function_25d0(v107); // 0x3ff5
                    gpm_report(342, "lib/liblow.c", 3, "%s: %s", (int64_t)"/dev/gpmctl", v110);
                    v109 = v110;
                    v108 = 0;
                }
                int64_t v111 = v108;
                int64_t v112 = v109;
                function_2440(*(int32_t *)g11);
                int64_t v113 = function_2570((int64_t)"/dev/gpmctl", 2); // 0x4040
                int32_t v114 = v113; // 0x404c
                *(int32_t *)g11 = v114;
                if (v114 == -1) {
                    int32_t v115 = *v106; // 0x44a9
                    if (v115 == 2) {
                        // 0x44df
                        gpm_report(352, "lib/liblow.c", 2, "Cannot find %s; ignoring (gpm disabled?)", (int64_t)"/dev/gpmctl", v112);
                        v12 = v84;
                        v78 = (int64_t)"/dev/gpmctl";
                        v79 = v112;
                        v9 = v94;
                        v10 = v99;
                        v11 = 0;
                        v116 = v84;
                        v117 = (int64_t)"/dev/gpmctl";
                        v118 = v112;
                        v119 = v94;
                        v120 = v99;
                        v121 = 1;
                        if (v111 == 1) {
                            goto lab_0x42db;
                        } else {
                            goto lab_0x42c0;
                        }
                    } else {
                        int64_t v122 = function_25d0(v115); // 0x44b0
                        gpm_report(356, "lib/liblow.c", 4, "%s: %s", (int64_t)"/dev/gpmctl", v122);
                        v12 = v84;
                        v78 = (int64_t)"/dev/gpmctl";
                        v79 = v122;
                        v9 = v94;
                        v10 = v99;
                        v11 = v111;
                        goto lab_0x42c0;
                    }
                } else {
                    int64_t v123 = function_25e0(v113 & 0xffffffff, &v92); // 0x4063
                    v90 = (int64_t)"/dev/gpmctl";
                    v91 = v112;
                    v87 = v94;
                    v88 = v111;
                    v89 = (int64_t)"lib/liblow.c";
                    v12 = v84;
                    v78 = (int64_t)"/dev/gpmctl";
                    v79 = v112;
                    v9 = v94;
                    v10 = v99;
                    v11 = v111;
                    int32_t v124; // 0x3d33
                    if ((v124 & 0xf000) == 0x2000 == ((int32_t)v123 != -1)) {
                        goto lab_0x3ecc;
                    } else {
                        goto lab_0x42c0;
                    }
                }
            }
        }
    } else {
        // 0x3ec5
        v90 = v125;
        v91 = v98;
        v87 = (int64_t)g11;
        v88 = v85;
        v89 = v105;
        goto lab_0x3ecc;
    }
  lab_0x43ab:;
    int64_t v126 = v36;
    int64_t v127 = g69; // 0x43ab
    int64_t v128 = function_24a0(v126 - 1 + function_23d0(v127), 0, 10); // 0x43c3
    *v46 = (int32_t)v128;
    v35 = v126;
    goto lab_0x4253;
  lab_0x40c7:
    // 0x40c7
    if ((int32_t)function_2390(2) != 0) {
        int64_t v129 = function_2520(2); // 0x4409
        v36 = v129;
        if (v129 != 0) {
            goto lab_0x43ab;
        } else {
            goto lab_0x40d9;
        }
    } else {
        goto lab_0x40d9;
    }
  lab_0x40d9:
    // 0x40d9
    gpm_report(278, "lib/liblow.c", 4, "checking tty name failed", v14, v13);
    int128_t * v130 = g11; // 0x40fb
    v12 = v16;
    v9 = (int64_t)v130;
    v10 = v45;
    v11 = v1;
    goto lab_0x42c0;
  lab_0x3ecc:;
    int64_t v141 = v91;
    int32_t * v142 = (int32_t *)v87; // 0x3ecc
    uint32_t v143 = *v142; // 0x3ecc
    int64_t v144; // 0x3d33
    int64_t v145; // 0x3d33
    if (function_23b0(v143, v146, 16) != 16) {
        int32_t v147 = *(int32_t *)function_2370((int64_t)v143); // 0x4440
        int64_t v148 = function_25d0(v147); // 0x4442
        gpm_report(106, "lib/liblow.c", 4, "write(): %s", v148, v141);
        v145 = v146;
        v144 = v148;
    } else {
        int64_t v149 = v90;
        int64_t v150 = &v92; // 0x3eef
        int64_t v151; // bp-208, 0x3d33
        function_2480(&v151);
        v92 = 0x2950;
        function_23a0(28, &v92, (int32_t)&g71);
        v145 = v150;
        v144 = v149;
        if (*v83 == 1) {
            // 0x4320
            v92 = 1;
            function_23a0(20, &v92, (int32_t)&g70);
            v145 = v150;
            v144 = v149;
            if (g70 != 1) {
                // 0x434e
                v92 = 0x4540;
                function_23a0(20, &v92, 0);
                v145 = v150;
                v144 = v149;
            }
        }
    }
    // 0x3f33
    result = *v142;
    v6 = v84;
    v5 = v145;
    v57 = v144;
    v59 = v141;
    v61 = v87;
    v62 = v99;
    v4 = v88;
    v63 = v89;
    goto lab_0x3f37;
}

// Address range: 0x4543 - 0x4650
int64_t function_4543(void) {
    int64_t v1 = __readfsqword(40); // 0x454f
    int64_t v2; // bp-440, 0x4543
    function_2480(&v2);
    function_2600(&v2, 20);
    int64_t v3; // bp-312, 0x4543
    function_2350(0, &v2, &v3);
    int64_t v4 = 0xffffffff0000; // bp-456, 0x45a0
    int64_t v5 = Gpm_Open(&v4, 0); // 0x45ac
    function_2350(2, &v3, NULL);
    function_23a0(20, &g70, 0);
    function_24c0(function_23c0() & 0xffffffff, 20);
    int64_t v6; // bp-176, 0x4543
    function_2480(&v6);
    int64_t v7 = 0x4540; // bp-184, 0x460f
    function_23a0(20, &v7, 0);
    if ((int32_t)v5 >= 0) {
        // 0x4620
        Gpm_Close();
    }
    int64_t result = v1 - __readfsqword(40); // 0x462d
    if (result != 0) {
        // 0x4644
        return function_23e0();
    }
    // 0x4638
    return result;
}

// Address range: 0x4650 - 0x4651
int64_t Gpm_Wgetch(void) {
    // 0x4650
    int64_t result; // 0x4650
    return result;
}

// Address range: 0x4653 - 0x4bac
int64_t function_4653(int64_t a1) {
    int64_t v1 = a1; // bp-216, 0x4665
    int64_t v2 = __readfsqword(40); // 0x4669
    int64_t v3; // 0x4653
    int64_t v4; // 0x4653
    int64_t v5; // 0x4653
    int64_t v6; // 0x4653
    int64_t v7; // 0x4653
    int64_t v8; // 0x4653
    if (*g25 == 0) {
        goto lab_0x4814;
    } else {
        int32_t v9 = *(int32_t *)g11; // 0x4692
        if (v9 == -1) {
            goto lab_0x4814;
        } else {
            uint32_t v10 = *g16; // 0x46a7
            int64_t v11 = v10; // 0x46a7
            if (v10 != 0) {
                // 0x4850
                v5 = v11;
                if (v2 == __readfsqword(40)) {
                    // 0x4867
                    return *(int64_t *)g17;
                }
                goto lab_0x4b32;
            } else {
                // 0x46b3
                *g14 = 0;
                if (v9 < 0) {
                    // 0x48d9
                    v3 = v11;
                    if (v9 == -2) {
                        uint32_t v12 = g39; // 0x48df
                        if (v12 != 0) {
                            int64_t v13 = (int64_t)v12 + 0xffffffff; // 0x4b6e
                            g39 = v13;
                            uint32_t v14 = *(int32_t *)(0x100000000 * v13 / 0x40000000 + (int64_t)&g38); // 0x4b80
                            v7 = (int64_t)&g38;
                            v3 = v14;
                        } else {
                            int64_t * v15 = (int64_t *)g18;
                            __asm_rep_stosq_memset((char *)&g37, 0, 15);
                            g36 = 1;
                            *v15 = 2;
                            while ((int32_t)function_24e0(1, &g36, 0, 0, v15) == 0) {
                                // 0x4909
                                __asm_rep_stosq_memset((char *)&g37, 0, 15);
                                g36 = 1;
                                *v15 = 2;
                            }
                            int64_t v16 = v1; // 0x4946
                            if (v1 == 0) {
                                // 0x4ae6
                                v16 = *(int64_t *)*(int64_t *)0x6fa0;
                            }
                            int64_t v17 = function_2560(v16); // 0x494c
                            while ((int32_t)v17 == 27) {
                                // 0x495d
                                __asm_rep_stosq_memset((char *)&g37, 0, 15);
                                g36 = 1;
                                g31 = 0x186a0;
                                if ((int32_t)function_24e0(1, &g36, 0, 0, &g30) == 0) {
                                    // break -> 0x48ad
                                    break;
                                }
                                int64_t v18 = v1; // 0x49a5
                                if (v1 == 0) {
                                    // 0x4b04
                                    v18 = *(int64_t *)*(int64_t *)0x6fa0;
                                }
                                int32_t v19 = function_2560(v18);
                                if (v19 != 91) {
                                    int64_t v20 = g39; // 0x4b13
                                    g39 = &g40;
                                    *(int32_t *)(4 * v20 + (int64_t)&g38) = v19;
                                    v7 = v20;
                                    v3 = v17 & 0xffffffff;
                                    goto lab_0x48ad;
                                }
                                // 0x49b9
                                __asm_rep_stosq_memset((char *)&g37, 0, 15);
                                g36 = 1;
                                g31 = 0x186a0;
                                if ((int32_t)function_24e0(1, &g36, 0, 0, &g30) == 0) {
                                    int32_t v21 = g39; // 0x4b89
                                    g39 = &g40;
                                    *(int32_t *)(4 * (int64_t)v21 + (int64_t)&g38) = 91;
                                    v7 = (int64_t)&g38;
                                    v3 = v17 & 0xffffffff;
                                    goto lab_0x48ad;
                                }
                                int64_t v22 = v1; // 0x4a01
                                if (v1 == 0) {
                                    // 0x4af5
                                    v22 = *(int64_t *)*(int64_t *)0x6fa0;
                                }
                                int64_t v23 = function_2560(v22); // 0x4a07
                                if ((int32_t)v23 != 77) {
                                    // 0x4b40
                                    v8 = v23 & 0xffffffff;
                                    v6 = v17 & 0xffffffff;
                                    goto lab_0x4b40_2;
                                }
                                int64_t v24; // bp-68, 0x4653
                                int64_t v25 = &v24;
                                int64_t v26 = v1; // 0x4a36
                                if (v1 == 0) {
                                    // 0x4ad7
                                    v26 = *(int64_t *)*(int64_t *)0x6fa0;
                                }
                                int64_t v27 = function_2560(v26); // 0x4a3c
                                int64_t v28 = v25 + 1; // 0x4a41
                                *(char *)v25 = (char)v27;
                                int64_t v29; // bp-65, 0x4653
                                while (v28 != (int64_t)&v29) {
                                    // 0x4a2f
                                    v25 = v28;
                                    v26 = v1;
                                    if (v1 == 0) {
                                        // 0x4ad7
                                        v26 = *(int64_t *)*(int64_t *)0x6fa0;
                                    }
                                    // 0x4a3c
                                    v27 = function_2560(v26);
                                    v28 = v25 + 1;
                                    *(char *)v25 = (char)v27;
                                }
                                // 0x4a50
                                gpm_convert_event((char *)&v24, &g42);
                                int64_t v30 = *(int64_t *)g17; // 0x4a62
                                v4 = v30;
                                if (v30 != 0 && (int32_t)v30 != 0) {
                                    goto lab_0x4a88_2;
                                }
                                __asm_rep_stosq_memset((char *)&g37, 0, 15);
                                g36 = 1;
                                *v15 = 2;
                                while ((int32_t)function_24e0(1, &g36, 0, 0, v15) == 0) {
                                    // 0x4909
                                    __asm_rep_stosq_memset((char *)&g37, 0, 15);
                                    g36 = 1;
                                    *v15 = 2;
                                }
                                // 0x493f
                                v16 = v1;
                                if (v1 == 0) {
                                    // 0x4ae6
                                    v16 = *(int64_t *)*(int64_t *)0x6fa0;
                                }
                                // 0x494c
                                v17 = function_2560(v16);
                            }
                            // 0x48ad
                            v7 = 0;
                            v3 = v17 & 0xffffffff;
                        }
                    }
                } else {
                    int64_t * v31 = (int64_t *)g18;
                    char v32; // bp-200, 0x4653
                    int64_t v33 = &v32;
                    while (true) {
                        int64_t v34; // 0x47ce
                        int64_t v35; // 0x47d2
                        int16_t v36; // 0x4653
                        int16_t v37; // 0x47d7
                        int16_t v38; // 0x47de
                        if (*g13 != 0) {
                            // 0x47b0
                            v34 = g19 + 1;
                            *(char *)v34 = 2;
                            v35 = *(int64_t *)g20;
                            v36 = (int16_t)*g23;
                            v37 = *(int16_t *)&g43 + v36;
                            *(int16_t *)v35 = v37;
                            *(int16_t *)(v35 + 4) = v37;
                            v38 = g44 + v36;
                            *(int16_t *)(v35 + 2) = v38;
                            *(int16_t *)(v35 + 6) = v38;
                            *(int16_t *)(v35 + 8) = 3;
                            function_2420(*g22, &g5, (int64_t *)v34, g19);
                        }
                        v32 = 1;
                        int64_t v39; // bp-192, 0x4653
                        __asm_rep_stosq_memset((char *)&v39, 0, 15);
                        uint32_t v40 = *(int32_t *)g11; // 0x470f
                        int64_t v41; // 0x4717
                        uint32_t v42; // 0x4653
                        int64_t * v43; // 0x472b
                        if (v40 >= 0) {
                            // 0x4717
                            v41 = function_23f0((int64_t)v40);
                            v42 = *(int32_t *)g11 % 64;
                            v43 = (int64_t *)((int64_t)&v1 + 16 + 8 * v41);
                            *v43 = (v42 == 0 ? 1 : 1 << (int64_t)v42) | *v43;
                        }
                        // 0x4730
                        *v31 = 2;
                        int64_t v44 = function_24e0((int64_t)(v9 + 1), (int64_t *)&v32, 0, 0, v31); // 0x4744
                        int32_t v45 = v44;
                        while (v45 == 0) {
                            // 0x46f8
                            v32 = 1;
                            __asm_rep_stosq_memset((char *)&v39, 0, 15);
                            v40 = *(int32_t *)g11;
                            if (v40 >= 0) {
                                // 0x4717
                                v41 = function_23f0((int64_t)v40);
                                v42 = *(int32_t *)g11 % 64;
                                v43 = (int64_t *)((int64_t)&v1 + 16 + 8 * v41);
                                *v43 = (v42 == 0 ? 1 : 1 << (int64_t)v42) | *v43;
                            }
                            // 0x4730
                            *v31 = 2;
                            v44 = function_24e0((int64_t)(v9 + 1), (int64_t *)&v32, 0, 0, v31);
                            v45 = v44;
                        }
                        // 0x474d
                        if (v32 % 2 != 0) {
                            // break (via goto) -> 0x4895
                            goto lab_0x4895;
                        }
                        while (v45 == -1) {
                            // 0x46e1
                            if (*g13 != 0) {
                                // 0x47b0
                                v34 = g19 + 1;
                                *(char *)v34 = 2;
                                v35 = *(int64_t *)g20;
                                v36 = (int16_t)*g23;
                                v37 = *(int16_t *)&g43 + v36;
                                *(int16_t *)v35 = v37;
                                *(int16_t *)(v35 + 4) = v37;
                                v38 = g44 + v36;
                                *(int16_t *)(v35 + 2) = v38;
                                *(int16_t *)(v35 + 6) = v38;
                                *(int16_t *)(v35 + 8) = 3;
                                function_2420(*g22, &g5, (int64_t *)v34, g19);
                            }
                            v32 = 1;
                            __asm_rep_stosq_memset((char *)&v39, 0, 15);
                            v40 = *(int32_t *)g11;
                            if (v40 >= 0) {
                                // 0x4717
                                v41 = function_23f0((int64_t)v40);
                                v42 = *(int32_t *)g11 % 64;
                                v43 = (int64_t *)((int64_t)&v1 + 16 + 8 * v41);
                                *v43 = (v42 == 0 ? 1 : 1 << (int64_t)v42) | *v43;
                            }
                            // 0x4730
                            *v31 = 2;
                            v44 = function_24e0((int64_t)(v9 + 1), (int64_t *)&v32, 0, 0, v31);
                            v45 = v44;
                            while (v45 == 0) {
                                // 0x46f8
                                v32 = 1;
                                __asm_rep_stosq_memset((char *)&v39, 0, 15);
                                v40 = *(int32_t *)g11;
                                if (v40 >= 0) {
                                    // 0x4717
                                    v41 = function_23f0((int64_t)v40);
                                    v42 = *(int32_t *)g11 % 64;
                                    v43 = (int64_t *)((int64_t)&v1 + 16 + 8 * v41);
                                    *v43 = (v42 == 0 ? 1 : 1 << (int64_t)v42) | *v43;
                                }
                                // 0x4730
                                *v31 = 2;
                                v44 = function_24e0((int64_t)(v9 + 1), (int64_t *)&v32, 0, 0, v31);
                                v45 = v44;
                            }
                            // 0x474d
                            if (v32 % 2 != 0) {
                                // break (via goto) -> 0x4895
                                goto lab_0x4895;
                            }
                        }
                        // 0x475d
                        if ((int32_t)Gpm_GetEvent(&g42, v33) != 0) {
                            int64_t v46 = *(int64_t *)g17; // 0x4778
                            v4 = v46;
                            if (v46 != 0 && (int32_t)v46 != 0) {
                                goto lab_0x4a88_2;
                            }
                        }
                    }
                  lab_0x4895:
                    // 0x4895
                    if (v1 == 0) {
                        // 0x4ac0
                        v7 = 0;
                        v3 = function_2560(*(int64_t *)*(int64_t *)0x6fa0) & 0xffffffff;
                    } else {
                        // 0x48a2
                        v7 = 0;
                        v3 = function_2560(v1) & 0xffffffff;
                    }
                }
                goto lab_0x48ad;
            }
        }
    }
  lab_0x4a88_2:
    // 0x4a88
    *g14 = 1;
    v7 = g21;
    v3 = v4 & 0xffffffff;
    goto lab_0x48ad;
  lab_0x4814:;
    int64_t v49 = __readfsqword(40);
    if (v1 == 0) {
        if (v2 == v49) {
            int64_t v50 = *(int64_t *)0x6fa0; // 0x4ab1
            int64_t * v51 = (int64_t *)v50; // 0x4abb
            int64_t * v52 = v51;
            int64_t v53 = *v52;
            return function_2560(v53);
        }
    } else {
        // 0x481f
        if (v2 == v49) {
            // 0x483a
            return function_2560(v1);
        }
    }
    goto lab_0x4b32;
  lab_0x4b32:
    // 0x4b32
    function_23e0();
    int64_t v48; // 0x4653
    v8 = v48;
    v6 = v5;
    goto lab_0x4b40_2;
  lab_0x4b40_2:
    // 0x4b40
    *(int32_t *)(4 * (int64_t)g39 + (int64_t)&g38) = (int32_t)v8;
    g39 = &g41;
    *(int32_t *)((int64_t)&g38 + 4 * (int64_t)(int32_t)&g40) = 91;
    v7 = &g41;
    v3 = v6;
    goto lab_0x48ad;
  lab_0x48ad:;
    int64_t v47 = v3;
    v48 = v7;
    v5 = v47;
    if (v2 == __readfsqword(40)) {
        // 0x48c4
        return v47 & 0xffffffff;
    }
    goto lab_0x4b32;
}

// Address range: 0x4bb0 - 0x4bb1
int64_t function_4bb0(void) {
    // 0x4bb0
    int64_t result; // 0x4bb0
    return result;
}

// Address range: 0x4bb3 - 0x4bf1
int64_t function_4bb3(void) {
    // 0x4bb3
    if (g7 == -1) {
        // 0x4be8
        return -1;
    }
    int64_t v1 = &g7; // 0x4bbf
    v1 -= 8;
    int64_t result = *(int64_t *)v1; // 0x4bda
    while (result != -1) {
        // 0x4bd8
        v1 -= 8;
        result = *(int64_t *)v1;
    }
    // 0x4be8
    return result;
}

// Address range: 0x4bf7 - 0x4c06
int64_t function_4bf7(void) {
    // 0x4bf7
    return function_26a0();
}

// --------------- Dynamically Linked Functions ---------------

// void __cxa_finalize(void * d);
// int * __errno_location(void);
// long int __fdelt_chk(long int d);
// void __gmon_start__(void);
// int __printf_chk(int flag, const char * restrict format, ...);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// void __syslog_chk(int pri, int flag, const char * fmt, ...);
// void __vsyslog_chk(int pri, int flag, const char * fmt, __gnuc_va_list ap);
// int close(int fd);
// int connect(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// void exit(int status);
// int fflush(FILE * stream);
// int fgetc(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// int fileno(FILE * stream);
// void free(void * ptr);
// int fstat(int fd, struct stat * buf);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int getc(FILE * stream);
// char * getenv(const char * name);
// __pid_t getpid(void);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// int ioctl(int fd, unsigned long int request, ...);
// int isatty(int fd);
// int kill(__pid_t pid, int sig);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int open(const char * file, int oflag, ...);
// int pclose(FILE * stream);
// FILE * popen(const char * command, const char * modes);
// ssize_t read(int fd, void * buf, size_t nbytes);
// int select(int nfds, fd_set * restrict readfds, fd_set * restrict writefds, fd_set * restrict exceptfds, struct timeval * restrict timeout);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// int sigaction(int sig, const struct sigaction * restrict act, struct sigaction * restrict oact);
// int sigaddset(sigset_t * set, int signo);
// int sigemptyset(sigset_t * set);
// int sigprocmask(int how, const sigset_t * restrict set, sigset_t * restrict oset);
// int socket(int domain, int type, int protocol);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int stat(const char * restrict file, struct stat * restrict buf);
// char * strdup(const char * s);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// char * ttyname(int fd);
// int64_t wgetch(void);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected functions: 152
